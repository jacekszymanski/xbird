/* Generated By:JavaCC: Do not edit this line. XQueryParser.java */
/*
 * @(#)$Id: XQueryParser.jj 3527 2008-02-24 14:15:39Z yui $
 *
 * Copyright 2006-2008 Makoto YUI
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Contributors:
 *     Makoto YUI - initial implementation
 */
package xbird.xquery.parser;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import javax.xml.XMLConstants;

import xbird.util.struct.Pair;
import xbird.util.xml.NamespaceBinder;
import xbird.util.xml.XMLUtils;
import xbird.xquery.Module;
import xbird.xquery.Pragma;
import xbird.xquery.XQueryConstants;
import xbird.xquery.XQueryException;
import xbird.xquery.XQueryModule;
import xbird.xquery.dm.value.AtomicValue;
import xbird.xquery.dm.value.literal.XDecimal;
import xbird.xquery.dm.value.literal.XDouble;
import xbird.xquery.dm.value.literal.XInteger;
import xbird.xquery.dm.value.literal.XString;
import xbird.xquery.expr.LiteralExpr;
import xbird.xquery.expr.XQExpression;
import xbird.xquery.expr.comp.ComparisonOp;
import xbird.xquery.expr.comp.GeneralComp;
import xbird.xquery.expr.comp.NodeComp;
import xbird.xquery.expr.comp.ValueComp;
import xbird.xquery.expr.cond.IfExpr;
import xbird.xquery.expr.cond.QuantifiedExpr;
import xbird.xquery.expr.constructor.AttributeConstructor;
import xbird.xquery.expr.constructor.AttributeConstructorBase;
import xbird.xquery.expr.constructor.CommentConstructor;
import xbird.xquery.expr.constructor.DocConstructor;
import xbird.xquery.expr.constructor.ElementConstructor;
import xbird.xquery.expr.constructor.NamespaceConstructor;
import xbird.xquery.expr.constructor.NodeConstructor;
import xbird.xquery.expr.constructor.PIConstructor;
import xbird.xquery.expr.constructor.TextConstructor;
import xbird.xquery.expr.constructor.TextContent;
import xbird.xquery.expr.decorative.ExtensionExpr;
import xbird.xquery.expr.decorative.ParenthesizedExpr;
import xbird.xquery.expr.decorative.UnorderedExpr;
import xbird.xquery.expr.dyna.ContextItemExpr;
import xbird.xquery.expr.dyna.ValidateOp;
import xbird.xquery.expr.ext.BDQExpr;
import xbird.xquery.expr.flwr.Binding;
import xbird.xquery.expr.flwr.FLWRExpr;
import xbird.xquery.expr.flwr.ForClause;
import xbird.xquery.expr.flwr.Grouping;
import xbird.xquery.expr.flwr.GroupingSpec;
import xbird.xquery.expr.flwr.LetClause;
import xbird.xquery.expr.flwr.OrderSpec;
import xbird.xquery.expr.logical.AndExpr;
import xbird.xquery.expr.logical.OrExpr;
import xbird.xquery.expr.math.AdditiveExpr;
import xbird.xquery.expr.math.MultiplicativeExpr;
import xbird.xquery.expr.math.NegativeExpr;
import xbird.xquery.expr.path.AbsolutePath;
import xbird.xquery.expr.path.FilterExpr;
import xbird.xquery.expr.path.NodeTest;
import xbird.xquery.expr.path.RelativePath;
import xbird.xquery.expr.path.StepExpr;
import xbird.xquery.expr.path.axis.AxisStep;
import xbird.xquery.expr.path.axis.DescendantOrSelfStep;
import xbird.xquery.expr.seq.ExceptOp;
import xbird.xquery.expr.seq.IntersectOp;
import xbird.xquery.expr.seq.RangeExpr;
import xbird.xquery.expr.seq.SequenceExpression;
import xbird.xquery.expr.seq.UnionOp;
import xbird.xquery.expr.types.CaseClause;
import xbird.xquery.expr.types.CastExpr;
import xbird.xquery.expr.types.CastableExpr;
import xbird.xquery.expr.types.InstanceofOp;
import xbird.xquery.expr.types.TreatExpr;
import xbird.xquery.expr.types.TypeswitchExpr;
import xbird.xquery.expr.var.VarRef;
import xbird.xquery.expr.var.Variable;
import xbird.xquery.expr.var.BindingVariable.CaseVariable;
import xbird.xquery.expr.var.BindingVariable.ExecHostVariable;
import xbird.xquery.expr.var.BindingVariable.ForVariable;
import xbird.xquery.expr.var.BindingVariable.LetVariable;
import xbird.xquery.expr.var.BindingVariable.ParametricVariable;
import xbird.xquery.expr.var.BindingVariable.PositionalVariable;
import xbird.xquery.expr.var.BindingVariable.QuantifiedVariable;
import xbird.xquery.func.UserFunction;
import xbird.xquery.meta.StaticContext;
import xbird.xquery.misc.ExpressionFactory;
import xbird.xquery.misc.QNameTable;
import xbird.xquery.misc.QNameUtil;
import xbird.xquery.misc.TypeFactory;
import xbird.xquery.misc.QNameTable.QualifiedName;
import xbird.xquery.type.AtomicType;
import xbird.xquery.type.ItemType;
import xbird.xquery.type.SequenceType;
import xbird.xquery.type.Type;
import xbird.xquery.type.Type.Occurrence;
import xbird.xquery.type.node.AttributeTest;
import xbird.xquery.type.node.DocumentTest;
import xbird.xquery.type.node.ElementTest;
import xbird.xquery.type.node.NodeType;
import xbird.xquery.type.node.PITest;
import xbird.xquery.type.node.SchemaAttributeTest;
import xbird.xquery.type.node.SchemaElementTest;
import xbird.xquery.type.xs.Untyped;

public class XQueryParser implements XQueryParserConstants {

    /** @see XQueryParserConstants */
    private static final String[] LEX_STATES = { "DEFAULT", "DECLAREORDERING", "OPERATOR",
            "QUERYVERSION", "NAMESPACEDECL", "URITOOPERATOR", "NAMESPACEKEYWORD", "XMLSPACE_DECL",
            "SINGLETYPE", "ITEMTYPE", "KINDTEST", "KINDTESTFORPI", "CLOSEKINDTEST", "OPTION",
            "PRAGMA", "PRAGMACONTENTS", "VARNAME", "EXPR_COMMENT", "NODETEST",
            "OCCURRENCEINDICATOR", "XQUERYD", "START_TAG", "END_TAG", "ELEMENT_CONTENT",
            "QUOT_ATTRIBUTE_CONTENT", "POS_ATTRIBUTE_CONTENT", "XML_COMMENT",
            "PROCESSING_INSTRUCTION", "PROCESSING_INSTRUCTION_CONTENT", "CDATA_SECTION" };

    // parse-time variables
    /** Whether currentModule is library module or not */
    private boolean isLibraryModule = false;

    /** parse state variables */
    private Token currentToken = null;

    /** main Module */
    private XQueryModule currentModule = null;

    /** static context */
    private StaticContext staticContext = new StaticContext();

    /** manages namespaces */
    private NamespaceBinder namespaceContext = staticContext.getStaticalyKnownNamespaces();

    private int baseURIDeclCount = 0;

    public XQueryModule parse() throws XQueryException {
        if(currentModule == null) {
            this.currentModule = new XQueryModule();
        }
        final XQueryModule m;
        try {
            m = parseModule(); // returned m is same to currentModule
        } catch (XQueryException xqe) {
            throw xqe;
        } catch (TokenMgrError tme) {
            throw new SyntaxError("err:XPST0003", getErrorMessage(tme, false), tme);
        } catch (ParseException pe) {
            throw new SyntaxError("err:XPST0003", getErrorMessage(pe, false), pe);
        } catch (Throwable e) {
            throw new XQueryException(getErrorMessage(e, true), e);
        }
        return m;
    }

    private String getErrorMessage(final Throwable e, final boolean printLineInfo) {
        final StringBuilder msg = new StringBuilder();
        final String errmsg = e.getMessage();
        if(errmsg != null) {
            msg.append(errmsg);
            msg.append('\n');
        }
        if(currentToken == null) {
            if(printLineInfo || errmsg == null) {
                msg.append("Parse failed"
                        + (isLibraryModule ? " at module '" + currentModule.getNamespace() + "'."
                                : ".\n"));
            }
        } else {
            if(printLineInfo) {
                msg.append("Parse failed before the line "
                        + currentToken.beginLine
                        + ", column "
                        + currentToken.beginColumn
                        + (isLibraryModule ? " at module '" + currentModule.getNamespace() + "'."
                                : ".\n"));
            }
            msg.append("\n---- detail of the error condition ----");
            msg.append("\n * curLexState: " + LEX_STATES[token_source.curLexState] + '('
                    + token_source.curLexState + ')');
            msg.append("\n * currentToken: `" + currentToken.image + "` ["
                    + XQueryParserConstants.tokenImage[currentToken.kind] + ']');
            if(currentToken.next != null) {
                msg.append("\n * nextToken: `" + currentToken.next.image + "` ["
                        + XQueryParserConstants.tokenImage[currentToken.next.kind] + ']');
            }
            if(currentToken.specialToken != null) {
                msg.append("\n * specialToken: " + currentToken.specialToken);
            }
            msg.append("\n * stateStack: ");
            for(int i = 0; i < token_source.stateStack.size(); i++) {
                if(i != 0) {
                    msg.append(' ');
                }
                final int stateNum = token_source.stateStack.elementAt(i);
                msg.append(LEX_STATES[stateNum] + '(' + stateNum + ')');
            }
            msg.append("\n--------------------------------------- \n");
        }
        return msg.toString();
    }

    public void setCurrentModule(XQueryModule module) {
        this.currentModule = module;
    }

    public void setStaticContext(StaticContext staticEnv) {
        this.staticContext = staticEnv;
        this.namespaceContext = staticEnv.getStaticalyKnownNamespaces();
    }

    public StaticContext getStaticContext() {
        return staticContext;
    }

    private boolean hasNamespace(String namespaceURI) {
        if(namespaceURI == null) {
            throw new IllegalArgumentException("Given namespaceURI is null.");
        }
        for(int i = 0; i < namespaceContext.getNamespaceCount(); i++) {
            String uri = namespaceContext.getNamespaceURI(i);
            if(uri.equals(namespaceURI)) {
                return true;
            }
        }
        return false;
    }

    private boolean hasNamespacePrefix(String prefix) {
        if(prefix == null) {
            return false;
        } else {
            return prefix.equals(namespaceContext.getNamespaceURI(prefix));
        }
    }

    private void declarePrefix(String prefix, String uri) throws XQueryException {
        if(!namespaceContext.declarePrefix(prefix, uri)) {
            error("err:XQST0070");
        }
    }

    private void error(String errorCode) throws XQueryException {
        throw new SyntaxError(errorCode, currentToken.beginLine, currentToken.beginColumn);
    }

    private static String unquote(String s) {
        return s.substring(1, s.length() - 1);
    }

    private static String unescape(String s) {
        return s.replace("\"\"", "\"").replace("''", "'");
    }

    private static String replaceReference(final String str) {
        assert (str != null) : str;
        final int strlen = str.length();
        final StringBuilder buf = new StringBuilder(strlen);
        for(int i = 0; i < strlen; i++) {
            char c = str.charAt(i);
            if(c == '&' && (i + 1) < strlen) {
                final int end = str.indexOf(";", i + 1);
                if(end == -1) {
                    buf.append(c);
                } else {
                    String ref = str.substring(i, end + 1);
                    String entity = parseCharRef(ref);
                    buf.append(entity);
                    i = end;
                }
            } else {
                buf.append(c);
            }
        }
        return buf.toString();
    }

    private static String parseCharRef(final String ref) {
        assert (ref != null) : ref;
        if(ref.startsWith("&#")) {
            final int value;
            if(ref.charAt(2) == 'x') {// hex digits
                String s = ref.substring(3, ref.length() - 1);
                value = Integer.parseInt(s, 16);
            } else {
                String s = ref.substring(2, ref.length() - 1);
                value = Integer.parseInt(s);
            }
            return Character.toString((char) value);
        } else if("&lt;".equals(ref)) {
            return "<";
        } else if("&gt;".equals(ref)) {
            return ">";
        } else if("&amp;".equals(ref)) {
            return "&";
        } else if("&quot;".equals(ref)) {
            return "\"";
        } else if("&apos;".equals(ref)) {
            return "'";
        } else {
            throw new IllegalStateException("Illegal character: " + ref);
        }
    }

    private XQExpression locate(XQExpression expr) {
        if(currentToken == null) {
            expr.setLocation(0, 0);
        } else {
            expr.setLocation(currentToken.beginLine, currentToken.beginColumn);
        }
        return expr;
    }

    private UserFunction locate(UserFunction func) {
        func.setLocation(currentToken.beginLine, currentToken.beginColumn);
        return func;
    }

    /************************************************************************
     Modules and Prologs
     (http://www.w3.org/TR/xquery/#id-query-prolog)

    [1]  Module			::=	VersionDecl? (MainModule | LibraryModule)
    [2]  VersionDecl	::=	<"xquery" "version"> StringLiteral ("encoding" StringLiteral)? Separator
    [3]  MainModule		::= Prolog QueryBody
    [27] QueryBody		::= Expr
    ************************************************************************/
    final public XQueryModule parseModule() throws ParseException, XQueryException {
        XQExpression expr = null;
        switch(jj_nt.kind) {
            case XQueryVersion:
                currentToken = jj_consume_token(XQueryVersion);
                currentToken = jj_consume_token(StringLiteralForVersion);
                String version = unquote(currentToken.image);
                if(version != null && version.compareTo(XQueryConstants.XQUERY_VERSION) > 0) {
                    error("err:XQST0031");
                }
                currentModule.setVersion(version);
                switch(jj_nt.kind) {
                    case XQueryEncoding:
                        currentToken = jj_consume_token(XQueryEncoding);
                        currentToken = jj_consume_token(StringLiteralForVersion);
                        String encoding = unquote(currentToken.image);
                        currentModule.setEncoding(encoding);
                        break;
                    default:
                        jj_la1[0] = jj_gen;
                        ;
                }
                currentToken = jj_consume_token(SemiColon);
                break;
            default:
                jj_la1[1] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case ModuleNamespace:
                this.isLibraryModule = true;
                parseLibraryModule();
                break;
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case DeclareConstruction:
            case DeclareDefaultOrder:
            case DeclareCollation:
            case DeclareNamespace:
            case DeclareBaseURI:
            case DeclareDefaultElement:
            case DeclareDefaultFunction:
            case ImportSchemaToken:
            case ImportModuleToken:
            case DeclareCopyNamespace:
            case Some:
            case Every:
            case DefineVariable:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case DeclareXMLSpace:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case DefineFunction:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case DeclareOrdering:
            case DeclareOption:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                parseProlog();
                expr = parseExpr();
                currentModule.setExpression(expr);
                break;
            default:
                jj_la1[2] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        jj_consume_token(0);
        {
            if(true)
                return currentModule;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [4] LibraryModule ::= ModuleDecl Prolog
    [5] ModuleDecl ::= <"module" "namespace"> NCName "=" URILiteral Separator
    [141] URILiteral ::= StringLiteral

     TODO err:XQST0048
    ************************************************************************/
    final public void parseLibraryModule() throws ParseException, XQueryException {
        String nsPrefix = null;
        String targetNamespace = null;
        //ModuleDecl
        currentToken = jj_consume_token(ModuleNamespace);
        currentToken = jj_consume_token(NCNameForPrefix);
        nsPrefix = currentToken.image;
        currentToken = jj_consume_token(AssignEquals);
        currentToken = jj_consume_token(URILiteral);
        targetNamespace = unquote(currentToken.image);
        currentToken = jj_consume_token(SemiColon);
        if(nsPrefix == null || targetNamespace == null) {
            error("err:XQST0048");
        }
        declarePrefix(nsPrefix, targetNamespace);
        currentModule.setNamespace(targetNamespace);
        parseProlog();
    }

    // ---------------------------------------------------------
    // Prolog entries

    /************************************************************************
    [6] Prolog ::= ((DefaultNamespaceDecl | Setter | NamespaceDecl | Import) Separator)* ((VarDecl | FunctionDecl | OptionDecl) Separator)*
    [7]	Setter ::= BoundarySpaceDecl | DefaultCollationDecl | BaseURIDecl | ConstructionDecl | OrderingModeDecl | EmptyOrderDecl | CopyNamespacesDecl
    [8] Import ::= SchemaImport | ModuleImport
    [13] OptionDecl ::= "declare" "option" QName StringLiteral

     NOTE: There is no default namespace for options.
    ************************************************************************/
    final public void parseProlog() throws ParseException, XQueryException {
        boolean isBoundarySpaceDeclCalled = false;
        boolean isCopyNamespacesDeclCalled = false;
        boolean isDefaultCollationDeclCalled = false;
        boolean isConstructionDeclCalled = false;
        boolean isOrderingModeDeclCalled = false;
        boolean isEmptyOrderingDeclCalled = false;
        QualifiedName optName = null;
        String optValue = null;
        label_1: while(true) {
            switch(jj_nt.kind) {
                case DeclareConstruction:
                case DeclareDefaultOrder:
                case DeclareCollation:
                case DeclareNamespace:
                case DeclareBaseURI:
                case DeclareDefaultElement:
                case DeclareDefaultFunction:
                case ImportSchemaToken:
                case ImportModuleToken:
                case DeclareCopyNamespace:
                case DeclareXMLSpace:
                case DeclareOrdering:
                    ;
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_1;
            }
            switch(jj_nt.kind) {
                case DeclareDefaultElement:
                case DeclareDefaultFunction:
                    parseDefaultNamespaceDecl();
                    break;
                case DeclareConstruction:
                case DeclareDefaultOrder:
                case DeclareCollation:
                case DeclareBaseURI:
                case DeclareCopyNamespace:
                case DeclareXMLSpace:
                case DeclareOrdering:
                    switch(jj_nt.kind) {
                        case DeclareXMLSpace:
                            if(isBoundarySpaceDeclCalled) {
                                error("err:XQST0068");
                            }
                            isBoundarySpaceDeclCalled = true;
                            parseBoundarySpaceDecl();
                            break;
                        case DeclareCollation:
                            if(isDefaultCollationDeclCalled) {
                                error("err:XQST0038");
                            }
                            isDefaultCollationDeclCalled = true;
                            parseDefaultCollationDecl();
                            break;
                        case DeclareBaseURI:
                            parseBaseURIDecl();
                            break;
                        case DeclareConstruction:
                            if(isConstructionDeclCalled) {
                                error("err:XQST0067");
                            }
                            isConstructionDeclCalled = true;
                            parseConstructionDecl();
                            break;
                        case DeclareOrdering:
                            if(isOrderingModeDeclCalled) {
                                error("err:XQST0065");
                            }
                            isOrderingModeDeclCalled = true;
                            parseOrderingModeDecl();
                            break;
                        case DeclareDefaultOrder:
                            if(isEmptyOrderingDeclCalled) {
                                error("err:XQST0069");
                            }
                            isEmptyOrderingDeclCalled = true;
                            parseEmptyOrderingDecl();
                            break;
                        case DeclareCopyNamespace:
                            if(isCopyNamespacesDeclCalled) {
                                error("err:XQST0055");
                            }
                            isCopyNamespacesDeclCalled = true;
                            parseCopyNamespacesDecl();
                            break;
                        default:
                            jj_la1[4] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                case DeclareNamespace:
                    parseNamespaceDecl();
                    break;
                case ImportSchemaToken:
                case ImportModuleToken:
                    switch(jj_nt.kind) {
                        case ImportSchemaToken:
                            parseSchemaImport();
                            break;
                        case ImportModuleToken:
                            parseModuleImport();
                            break;
                        default:
                            jj_la1[5] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    break;
                default:
                    jj_la1[6] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            currentToken = jj_consume_token(SemiColon);
        }
        label_2: while(true) {
            switch(jj_nt.kind) {
                case DefineVariable:
                case DefineFunction:
                case DeclareOption:
                    ;
                    break;
                default:
                    jj_la1[7] = jj_gen;
                    break label_2;
            }
            switch(jj_nt.kind) {
                case DefineVariable:
                    parseVarDecl();
                    break;
                case DefineFunction:
                    parseFunctionDecl();
                    break;
                case DeclareOption:
                    //OptionDecl
                    currentToken = jj_consume_token(DeclareOption);
                    currentToken = jj_consume_token(QNameForOption);
                    optName = QNameUtil.parse(currentToken.image, namespaceContext, null);
                    currentToken = jj_consume_token(StringLiteral);
                    optValue = unquote(currentToken.image);
                    staticContext.putOption(optName, optValue);
                    break;
                default:
                    jj_la1[8] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            currentToken = jj_consume_token(SemiColon);
        }
    }

    /************************************************************************
    [11] BoundarySpaceDecl ::= "declare" "boundary-space" ("preserve" | "strip")
    ************************************************************************/
    final public void parseBoundarySpaceDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareXMLSpace);
        switch(jj_nt.kind) {
            case XMLSpacePreserve:
                currentToken = jj_consume_token(XMLSpacePreserve);
                staticContext.setStripBoundarySpace(false);
                break;
            case XMLSpaceStrip:
                currentToken = jj_consume_token(XMLSpaceStrip);
                staticContext.setStripBoundarySpace(true);
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    /************************************************************************
    [16] DefaultCollationDecl ::= <"declare" "default" "collation"> URILiteral
    ************************************************************************/
    final public void parseDefaultCollationDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareCollation);
        currentToken = jj_consume_token(URILiteral);
        String collation = unquote(currentToken.image);
        staticContext.setDefaultCollation(collation);
    }

    /************************************************************************
    [17] BaseURIDecl ::= <"declare" "base-uri"> URILiteral
    ************************************************************************/
    final public void parseBaseURIDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareBaseURI);
        currentToken = jj_consume_token(URILiteral);
        if(++baseURIDeclCount > 1) {
            error("err:XQST0032");
        }
        String uri = unquote(currentToken.image);
        staticContext.setBaseURI(uri);
    }

    /************************************************************************
    [22] ConstructionDecl ::= <"declare" "construction"> ("preserve" | "strip")
    ************************************************************************/
    final public void parseConstructionDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareConstruction);
        currentToken = jj_consume_token(SchemaModeForDeclareConstruction);
        staticContext.setConstructionModeStrip(currentToken.image.startsWith("p"));
    }

    /************************************************************************
    [13] OrderingModeDecl ::= <"declare" "ordering"> ("ordered" | "unordered")
    ************************************************************************/
    final public void parseOrderingModeDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareOrdering);
        switch(jj_nt.kind) {
            case Ordered:
                currentToken = jj_consume_token(Ordered);
                staticContext.setOrderingModeOrdered(true);
                break;
            case Unordered:
                currentToken = jj_consume_token(Unordered);
                staticContext.setOrderingModeOrdered(false);
                break;
            default:
                jj_la1[10] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    /************************************************************************
    [14] EmptyOrderingDecl ::= <"declare" "default" "order"> (<"empty" "greatest"> | <"empty" "least">)
    ************************************************************************/
    final public void parseEmptyOrderingDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareDefaultOrder);
        switch(jj_nt.kind) {
            case EmptyGreatest:
                currentToken = jj_consume_token(EmptyGreatest);
                staticContext.setEmptyLeast(false);
                break;
            case EmptyLeast:
                currentToken = jj_consume_token(EmptyLeast);
                staticContext.setEmptyLeast(true);
                break;
            default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    /************************************************************************
    [16] CopyNamespacesDecl ::= "declare" "copy-namespaces" PreserveMode "," InheritMode
    [17] PreserveMode 	    ::= "preserve" | "no-preserve"
    [18] InheritMode 	    ::= "inherit" | "no-inherit"
    ************************************************************************/
    final public void parseCopyNamespacesDecl() throws ParseException, XQueryException {
        currentToken = jj_consume_token(DeclareCopyNamespace);
        switch(jj_nt.kind) {
            case Preserve:
                currentToken = jj_consume_token(Preserve);
                staticContext.setPreserveNamespace(true);
                break;
            case NoPreserve:
                currentToken = jj_consume_token(NoPreserve);
                staticContext.setPreserveNamespace(false);
                break;
            default:
                jj_la1[12] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(CommaForCopyNamespace);
        switch(jj_nt.kind) {
            case Inherit:
                currentToken = jj_consume_token(Inherit);
                staticContext.setInheritNamespace(true);
                break;
            case NoInherit:
                currentToken = jj_consume_token(NoInherit);
                staticContext.setInheritNamespace(false);
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
    }

    /************************************************************************
    [18] SchemaImport ::= 	<"import" "schema"> SchemaPrefix? URILiteral (<"at" URILiteral> ("," URILiteral)*)?
    [19] SchemaPrefix ::= ("namespace" NCName "=") | (<"default" "element"> "namespace")

     TODO: err:XQST0059, err:XQST0035, err:XQST0012
    ************************************************************************/
    final public void parseSchemaImport() throws ParseException, XQueryException {
        boolean hasNamespacePrefix = false;
        boolean hasDefaultElementNamespace = false;
        String nsPrefix = null;
        final String nsuri;
        List<String> locationHints = null;
        currentToken = jj_consume_token(ImportSchemaToken);
        switch(jj_nt.kind) {
            case Namespace:
            case DefaultElement:
                switch(jj_nt.kind) {
                    case Namespace:
                        currentToken = jj_consume_token(Namespace);
                        currentToken = jj_consume_token(NCNameForPrefix);
                        hasNamespacePrefix = true;
                        nsPrefix = currentToken.image;
                        currentToken = jj_consume_token(AssignEquals);
                        break;
                    case DefaultElement:
                        currentToken = jj_consume_token(DefaultElement);
                        currentToken = jj_consume_token(Namespace);
                        hasDefaultElementNamespace = true;
                        break;
                    default:
                        jj_la1[14] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[15] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(URILiteral);
        nsuri = unquote(currentToken.image);
        switch(jj_nt.kind) {
            case AtURILiteral:
                currentToken = jj_consume_token(AtURILiteral);
                String location = currentToken.image.substring(currentToken.image.indexOf('"') + 1, currentToken.image.length() - 1);
                locationHints = new ArrayList<String>(2);
                locationHints.add(location);
                label_3: while(true) {
                    switch(jj_nt.kind) {
                        case CommaForURITransition:
                            ;
                            break;
                        default:
                            jj_la1[16] = jj_gen;
                            break label_3;
                    }
                    currentToken = jj_consume_token(CommaForURITransition);
                    currentToken = jj_consume_token(AtURILiteral);
                    location = unquote(currentToken.image);
                    locationHints.add(location);
                }
                break;
            default:
                jj_la1[17] = jj_gen;
                ;
        }
        if(hasNamespace(nsuri)) {
            error("err:XQST0058");
        }
        if(hasNamespacePrefix) {
            if(nsuri.length() == 0) {
                error("err:XQST0057");
            }
            declarePrefix(nsPrefix, nsuri);
        } else if(hasDefaultElementNamespace) {
            staticContext.setDefaultElementNamespace(nsuri);
        }
        // TODO import schemas

    }

    /************************************************************************
    [20] ModuleImport ::= <"import" "module"> ("namespace" NCName "=")? URILiteral 
    					(<"at" URILiteral> ("," URILiteral)*)?
    					
     TODO: err:XQST0036
    ************************************************************************/
    final public void parseModuleImport() throws ParseException, XQueryException {
        String nsPrefix = null;
        final String targetNamespace;
        List<String> locationHints = null;
        currentToken = jj_consume_token(ImportModuleToken);
        switch(jj_nt.kind) {
            case Namespace:
                currentToken = jj_consume_token(Namespace);
                currentToken = jj_consume_token(NCNameForPrefix);
                nsPrefix = currentToken.image;
                currentToken = jj_consume_token(AssignEquals);
                break;
            default:
                jj_la1[18] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(URILiteral);
        targetNamespace = unquote(currentToken.image);
        switch(jj_nt.kind) {
            case AtURILiteral:
                currentToken = jj_consume_token(AtURILiteral);
                String location = currentToken.image.substring(currentToken.image.indexOf('"') + 1, currentToken.image.length() - 1);
                locationHints = new ArrayList<String>(2);
                locationHints.add(location);
                label_4: while(true) {
                    switch(jj_nt.kind) {
                        case CommaForURITransition:
                            ;
                            break;
                        default:
                            jj_la1[19] = jj_gen;
                            break label_4;
                    }
                    currentToken = jj_consume_token(CommaForURITransition);
                    currentToken = jj_consume_token(URILiteral);
                    location = unquote(currentToken.image);
                    locationHints.add(location);
                }
                break;
            default:
                jj_la1[20] = jj_gen;
                ;
        }
        if(targetNamespace.length() == 0) {
            error("err:XQST0088"); // zero length namespace
        }
        if(hasNamespace(targetNamespace)) {
            error("err:XQST0047"); // multiple module imports in the same Prolog specify the same target namespace.
        }
        // prevent circular reference.
        for(Module mod = currentModule; mod != null; mod = mod.getParentModule()) {
            if(targetNamespace.equals(mod.getNamespace())) {
                error("err:XQST0073");
            }
        }
        declarePrefix(nsPrefix, targetNamespace);
        // load library module
        final Module module;
        if(locationHints != null) {
            // TODO [Limitation] multiple location hints does not mean.
            module = staticContext.getModuleManager().loadModule(targetNamespace, locationHints.get(0));
        } else {
            module = staticContext.getModuleManager().loadModule(targetNamespace);
        }
        currentModule.importVariables(module);
        currentModule.importFunctions(module);
    }

    /************************************************************************
    [10] NamespaceDecl ::= <"declare" "namespace"> NCName "=" URILiteral
    [141] URILiteraly::= StringLiteral
    ************************************************************************/
    final public void parseNamespaceDecl() throws ParseException, XQueryException {
        String prefix = null;
        String nsuri = null;
        currentToken = jj_consume_token(DeclareNamespace);
        currentToken = jj_consume_token(NCNameForPrefix);
        prefix = currentToken.image;
        currentToken = jj_consume_token(AssignEquals);
        currentToken = jj_consume_token(URILiteral);
        nsuri = unquote(currentToken.image);
        if(hasNamespacePrefix(prefix)) {
            error("err:XQST0033");
        }
        declarePrefix(prefix, nsuri);
    }

    /************************************************************************
    [12] DefaultNamespaceDecl ::= (("declare" "default" "element") | ("declare" "default" "function")) 
    							"namespace" URILiteral
     TODO: err:XP0017
    ************************************************************************/
    final public void parseDefaultNamespaceDecl() throws ParseException, XQueryException {
        boolean functionDecl = false;
        String nsuri = null;
        switch(jj_nt.kind) {
            case DeclareDefaultElement:
                currentToken = jj_consume_token(DeclareDefaultElement);
                break;
            case DeclareDefaultFunction:
                currentToken = jj_consume_token(DeclareDefaultFunction);
                functionDecl = true;
                break;
            default:
                jj_la1[21] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(Namespace);
        currentToken = jj_consume_token(URILiteral);
        nsuri = unquote(currentToken.image);
        if(nsuri == null) {
            error("err:XQST0046");
        }
        if(functionDecl) { // default function namespace declaration
            if(staticContext.getDefaultFunctionNamespace() != null) {
                error("err:XQST0066");
            }
            if(nsuri.length() == 0) {
                nsuri = StaticContext.DEFAULT_NAMESPACE;
            }
            staticContext.setDefaultFunctionNamespace(nsuri);
        } else { // default element/type namespace declaration
            if(staticContext.getDefaultElementNamespace() != null) {
                error("err:XQST0066");
            }
            if(nsuri.length() == 0) {
                nsuri = StaticContext.DEFAULT_NAMESPACE;
            }
            staticContext.setDefaultElementNamespace(nsuri);
        }
    }

    /************************************************************************
    [21]  VarDecl ::= "declare" "variable" "$" QName TypeDeclaration? ((":=" ExprSingle) | "external")
    [110] TypeDeclaration ::= "as" SequenceType

     TODO: err:XPTY0004, err:XQST0054, err:XP0006
    ************************************************************************/
    final public void parseVarDecl() throws ParseException, XQueryException {
        final QualifiedName varName;
        Type varType = null;
        XQExpression valueExpr = null;
        boolean isExternal = false;
        currentToken = jj_consume_token(DefineVariable);
        // TODO spaces afrer "$"
        currentToken = jj_consume_token(VarName);
        varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
        switch(jj_nt.kind) {
            case As:
                currentToken = jj_consume_token(As);
                varType = parseSequenceType();
                break;
            default:
                jj_la1[22] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case ColonEquals:
                currentToken = jj_consume_token(ColonEquals);
                valueExpr = parseExprSingle();
                break;
            case External:
                currentToken = jj_consume_token(External);
                isExternal = true;
                break;
            default:
                jj_la1[23] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        final Variable variable;
        if(isExternal) {
            Variable extVar = currentModule.getVariable(varName);
            if(extVar != null) {
                variable = extVar;
            } else {
                variable = ExpressionFactory.createExternalVariable(varName, currentModule);
                currentModule.putVariable(varName, variable);
            }
        } else { // internal
            if(isLibraryModule) {
                final String expectedNamespace = currentModule.getNamespace();
                if(expectedNamespace != null) {
                    if(!expectedNamespace.equals(varName.getNamespaceURI())) {
                        error("err:XQST0048");
                    }
                }
            }
            variable = currentModule.declareGlobalVariable(varName, valueExpr); // may causes err:XQ0049
        }
        locate(variable);
        if(varType != null) {
            variable.setType(varType);
        }
    }

    /************************************************************************
    [23] FunctionDecl ::= <"declare" "function"> <QName "("> ParamList? (")" | (<")" "as"> SequenceType)) (EnclosedExpr | "external")
    [26] EnclosedExpr ::= "{" Expr "}"
    ************************************************************************/
    final public void parseFunctionDecl() throws ParseException, XQueryException {
        final UserFunction func;
        final QualifiedName funcName;
        List<ParametricVariable> paramList = Collections.<ParametricVariable> emptyList();
        Type returnType = Untyped.UNTYPED;
        final XQExpression funcBody;
        currentModule.pushVarScope();
        currentToken = jj_consume_token(DefineFunction);
        currentToken = jj_consume_token(QNameLpar);
        funcName = QNameUtil.parse(currentToken.image.substring(0, currentToken.image.length() - 1).trim(), namespaceContext, staticContext.getDefaultFunctionNamespace());
        switch(jj_nt.kind) {
            case VariableIndicator:
                paramList = parseParamList();
                break;
            default:
                jj_la1[24] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case Rpar:
                currentToken = jj_consume_token(Rpar);
                break;
            case RparAs:
                currentToken = jj_consume_token(RparAs);
                returnType = parseSequenceType();
                break;
            default:
                jj_la1[25] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        final String nsuri = funcName.getNamespaceURI();
        if(isLibraryModule) {
            final String tn = currentModule.getNamespace();
            if(tn == null) { // sanity check
                error("err:XQST0046");
            }
            if(tn.equals(nsuri) == false) {
                error("err:XQST0048");
            }
        } else {
            UserFunction.checkAsPredefinedFunction(nsuri);
        }
        func = ExpressionFactory.createUserFunction(currentModule, funcName, paramList, returnType);
        switch(jj_nt.kind) {
            case LbraceExprEnclosure:
                currentToken = jj_consume_token(LbraceExprEnclosure);
                funcBody = parseExpr();
                func.setBodyExpression(funcBody);
                currentToken = jj_consume_token(Rbrace);
                break;
            case External:
                currentToken = jj_consume_token(External);
                func.setExternal(true);
                break;
            default:
                jj_la1[26] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        locate(func);
        currentModule.popVarScope();
    }

    /************************************************************************
    [24]  ParamList ::= Param ("," Param)*
    [25]  Param ::= "$" QName TypeDeclaration?
    [110] TypeDeclaration ::= "as" SequenceType
    ************************************************************************/
    final public List<ParametricVariable> parseParamList() throws ParseException, XQueryException {
        final List<ParametricVariable> paramList = new LinkedList<ParametricVariable>();
        QualifiedName paramName;
        ParametricVariable param;
        Type paramType = null;
        currentToken = jj_consume_token(VariableIndicator);
        currentToken = jj_consume_token(VarName);
        paramName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
        param = new ParametricVariable(paramName);
        currentModule.putVariable(paramName, param);
        switch(jj_nt.kind) {
            case As:
                currentToken = jj_consume_token(As);
                paramType = parseSequenceType();
                param.setType(paramType);
                break;
            default:
                jj_la1[27] = jj_gen;
                ;
        }
        paramList.add(param);
        label_5: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    break label_5;
            }
            currentToken = jj_consume_token(Comma);
            currentToken = jj_consume_token(VariableIndicator);
            currentToken = jj_consume_token(VarName);
            paramName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
            param = new ParametricVariable(paramName);
            currentModule.putVariable(paramName, param);
            switch(jj_nt.kind) {
                case As:
                    currentToken = jj_consume_token(As);
                    paramType = parseSequenceType();
                    param.setType(paramType);
                    break;
                default:
                    jj_la1[29] = jj_gen;
                    ;
            }
            if(paramList.contains(param)) {
                error("err:XQST0039");
            }
            paramList.add(param);
        }
        {
            if(true)
                return paramList;
        }
        throw new Error("Missing return statement in function");
    }

    // ---------------------------------------------------------
    // SequenceType entries (http://www.w3.org/TR/xquery/#doc-xquery-SequenceType)

    /************************************************************************
    [119] SequenceType ::= ("empty-sequence" "(" ")") | (ItemType OccurrenceIndicator?)
    [112] OccurrenceIndicator ::= "?" | "*" | "+" 	
    [121] ItemType 	   ::= KindTest | ("item" "(" ")") | AtomicType
    AtomicType | KindTest | <"item" "(" ")">
    [114] AtomicType   ::= QName
    ************************************************************************/
    final public Type parseSequenceType() throws ParseException, XQueryException {
        boolean isAtomic = false;
        final ItemType itemType;
        Occurrence occurrenceIndicator = Occurrence.OCC_EXACTLY_ONE;
        switch(jj_nt.kind) {
            case EmptySequence:
                currentToken = jj_consume_token(EmptySequence);
                {
                    if(true)
                        return SequenceType.EMPTY;
                }
                break;
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case QNameForSequenceType:
            case Item:
            case QNameForAtomicType:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
                switch(jj_nt.kind) {
                    case ElementType:
                    case AttributeType:
                    case SchemaElementType:
                    case SchemaAttributeType:
                    case CommentLparRpar:
                    case TextLparRpar:
                    case NodeLparRpar:
                    case DocumentLpar:
                    case ProcessingInstructionLpar:
                    case ElementTypeForKindTest:
                    case AttributeTypeForKindTest:
                    case SchemaElementTypeForKindTest:
                    case SchemaAttributeTypeForKindTest:
                    case CommentLparRparForKindTest:
                    case TextLparRparForKindTest:
                    case NodeLparRparForKindTest:
                    case DocumentLparForKindTest:
                    case ProcessingInstructionLparForKindTest:
                    case ElementTypeForDocumentTest:
                    case SchemaElementTypeForDocumentTest:
                        // ItemType
                        itemType = parseKindTest();
                        break;
                    case Item:
                        currentToken = jj_consume_token(Item);
                        itemType = ItemType.ANY_ITEM;
                        break;
                    case QNameForSequenceType:
                    case QNameForAtomicType:
                        switch(jj_nt.kind) {
                            case QNameForAtomicType:
                                // AtomicType
                                currentToken = jj_consume_token(QNameForAtomicType);
                                isAtomic = true;
                                break;
                            case QNameForSequenceType:
                                currentToken = jj_consume_token(QNameForSequenceType);
                                break;
                            default:
                                jj_la1[30] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        QualifiedName itemName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                        itemType = TypeFactory.createAtomicType(itemName, staticContext);
                        break;
                    default:
                        jj_la1[31] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch(jj_nt.kind) {
                    case Star:
                    case OccurrenceZeroOrOne:
                    case OccurrenceOneOrMore:
                        switch(jj_nt.kind) {
                            case OccurrenceZeroOrOne:
                                //OccurrenceIndicator
                                currentToken = jj_consume_token(OccurrenceZeroOrOne);
                                occurrenceIndicator = Occurrence.OCC_ZERO_OR_ONE;
                                break;
                            case Star:
                                currentToken = jj_consume_token(Star);
                                occurrenceIndicator = Occurrence.OCC_ZERO_OR_MORE;
                                break;
                            case OccurrenceOneOrMore:
                                currentToken = jj_consume_token(OccurrenceOneOrMore);
                                occurrenceIndicator = Occurrence.OCC_ONE_OR_MORE;
                                break;
                            default:
                                jj_la1[32] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[33] = jj_gen;
                        ;
                }
                break;
            default:
                jj_la1[34] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if(isAtomic && occurrenceIndicator == Occurrence.OCC_EXACTLY_ONE) {
            {
                if(true)
                    return itemType;
            }
        } else {
            {
                if(true)
                    return TypeFactory.createSequenceType(itemType, occurrenceIndicator);
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [121] KindTest 	   ::= DocumentTest
    						| ElementTest
    						| AttributeTest
    						| SchemaElementTest
    						| SchemaAttributeTest
    						| PITest
    						| CommentTest
    						| TextTest
    						| AnyKindTest
    [122] AnyKindTest ::= <"node" "("> ")"
    [124] TextTest 	  ::= <"text" "("> ")"
    [125] CommentTest ::= <"comment" "("> ")"
    ************************************************************************/
    final public NodeType parseKindTest() throws ParseException, XQueryException {
        final NodeType nodeType;
        switch(jj_nt.kind) {
            case DocumentLpar:
            case DocumentLparForKindTest:
                nodeType = parseDocumentTest();
                break;
            case ElementType:
            case ElementTypeForKindTest:
            case ElementTypeForDocumentTest:
                nodeType = parseElementTest();
                break;
            case AttributeType:
            case AttributeTypeForKindTest:
                nodeType = parseAttributeTest();
                break;
            case SchemaElementType:
            case SchemaElementTypeForKindTest:
            case SchemaElementTypeForDocumentTest:
                nodeType = parseSchemaElementTest();
                break;
            case SchemaAttributeType:
            case SchemaAttributeTypeForKindTest:
                nodeType = parseSchemaAttributeTest();
                break;
            case ProcessingInstructionLpar:
            case ProcessingInstructionLparForKindTest:
                nodeType = parsePITest();
                break;
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
                switch(jj_nt.kind) {
                    case CommentLparRpar:
                    case CommentLparRparForKindTest:
                        switch(jj_nt.kind) {
                            case CommentLparRpar:
                                currentToken = jj_consume_token(CommentLparRpar);
                                break;
                            case CommentLparRparForKindTest:
                                currentToken = jj_consume_token(CommentLparRparForKindTest);
                                break;
                            default:
                                jj_la1[35] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        nodeType = NodeType.COMMENT;
                        break;
                    case TextLparRpar:
                    case TextLparRparForKindTest:
                        switch(jj_nt.kind) {
                            case TextLparRpar:
                                currentToken = jj_consume_token(TextLparRpar);
                                break;
                            case TextLparRparForKindTest:
                                currentToken = jj_consume_token(TextLparRparForKindTest);
                                break;
                            default:
                                jj_la1[36] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        nodeType = NodeType.TEXT;
                        break;
                    case NodeLparRpar:
                    case NodeLparRparForKindTest:
                        switch(jj_nt.kind) {
                            case NodeLparRpar:
                                currentToken = jj_consume_token(NodeLparRpar);
                                break;
                            case NodeLparRparForKindTest:
                                currentToken = jj_consume_token(NodeLparRparForKindTest);
                                break;
                            default:
                                jj_la1[37] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        nodeType = NodeType.ANYNODE;
                        break;
                    default:
                        jj_la1[38] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[39] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return nodeType;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [123] DocumentTest ::= "document-node" "(" (ElementTest | SchemaElementTest)? ")"
    ************************************************************************/
    final public DocumentTest parseDocumentTest() throws ParseException, XQueryException {
        ItemType itemType = null;
        switch(jj_nt.kind) {
            case DocumentLpar:
                currentToken = jj_consume_token(DocumentLpar);
                break;
            case DocumentLparForKindTest:
                currentToken = jj_consume_token(DocumentLparForKindTest);
                break;
            default:
                jj_la1[40] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case ElementType:
            case SchemaElementType:
            case ElementTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
                switch(jj_nt.kind) {
                    case ElementType:
                    case ElementTypeForKindTest:
                    case ElementTypeForDocumentTest:
                        itemType = parseElementTest();
                        break;
                    case SchemaElementType:
                    case SchemaElementTypeForKindTest:
                    case SchemaElementTypeForDocumentTest:
                        itemType = parseSchemaElementTest();
                        break;
                    default:
                        jj_la1[41] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[42] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(RparForKindTest);
        {
            if(true)
                return TypeFactory.createDocumentTest(itemType);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [126] PITest 	   ::= "processing-instruction" "(" (NCName | StringLiteral)? ")"
    ************************************************************************/
    final public PITest parsePITest() throws ParseException, XQueryException {
        String name = null;
        switch(jj_nt.kind) {
            case ProcessingInstructionLpar:
                currentToken = jj_consume_token(ProcessingInstructionLpar);
                break;
            case ProcessingInstructionLparForKindTest:
                currentToken = jj_consume_token(ProcessingInstructionLparForKindTest);
                break;
            default:
                jj_la1[43] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case NCNameForPI:
            case StringLiteralForKindTest:
                switch(jj_nt.kind) {
                    case NCNameForPI:
                        currentToken = jj_consume_token(NCNameForPI);
                        name = currentToken.image;
                        break;
                    case StringLiteralForKindTest:
                        currentToken = jj_consume_token(StringLiteralForKindTest);
                        name = unquote(currentToken.image);
                        break;
                    default:
                        jj_la1[44] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[45] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(RparForKindTest);
        {
            if(true)
                return TypeFactory.createPITest(name);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [131] ElementTest ::= <"element" "("> (ElementNameOrWildcard ("," TypeName "?"?)?)? ")"
    [132] ElementNameOrWildcard ::= ElementName | "*"
    [136] ElementName ::= QName
    [137] TypeName ::= QName
    ************************************************************************/
    final public ElementTest parseElementTest() throws ParseException, XQueryException {
        QualifiedName elementName = null;
        QualifiedName typeName = null;
        boolean isNillable = false;
        switch(jj_nt.kind) {
            case ElementType:
                currentToken = jj_consume_token(ElementType);
                break;
            case ElementTypeForKindTest:
                currentToken = jj_consume_token(ElementTypeForKindTest);
                break;
            case ElementTypeForDocumentTest:
                currentToken = jj_consume_token(ElementTypeForDocumentTest);
                break;
            default:
                jj_la1[46] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case AnyName:
            case QNameForItemType:
                switch(jj_nt.kind) {
                    case QNameForItemType:
                        currentToken = jj_consume_token(QNameForItemType);
                        elementName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                        break;
                    case AnyName:
                        currentToken = jj_consume_token(AnyName);
                        break;
                    default:
                        jj_la1[47] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch(jj_nt.kind) {
                    case CommaForKindTest:
                        currentToken = jj_consume_token(CommaForKindTest);
                        currentToken = jj_consume_token(QNameForItemType);
                        typeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                        switch(jj_nt.kind) {
                            case Nillable:
                                currentToken = jj_consume_token(Nillable);
                                isNillable = true;
                                break;
                            default:
                                jj_la1[48] = jj_gen;
                                ;
                        }
                        break;
                    default:
                        jj_la1[49] = jj_gen;
                        ;
                }
                break;
            default:
                jj_la1[50] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(RparForKindTest);
        {
            if(true)
                return TypeFactory.createElementTest(elementName, typeName, isNillable);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [133] SchemaElementTest  ::= <"schema-element" "("> ElementDeclaration ")"
    [134] ElementDeclaration ::= ElementName
    [136] ElementName 	     ::= QName
    ************************************************************************/
    final public SchemaElementTest parseSchemaElementTest() throws ParseException, XQueryException {
        QualifiedName elementName = null;
        switch(jj_nt.kind) {
            case SchemaElementType:
                currentToken = jj_consume_token(SchemaElementType);
                break;
            case SchemaElementTypeForKindTest:
                currentToken = jj_consume_token(SchemaElementTypeForKindTest);
                break;
            case SchemaElementTypeForDocumentTest:
                currentToken = jj_consume_token(SchemaElementTypeForDocumentTest);
                break;
            default:
                jj_la1[51] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(QNameForItemType);
        elementName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
        currentToken = jj_consume_token(RparForKindTest);
        if(elementName == null) {
            error("err:XPST0008");
        }
        {
            if(true)
                return TypeFactory.createSchemaElementTest(elementName);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [127] AttributeTest 	   ::= <"attribute" "("> (AttribNameOrWildcard ("," TypeName)?)? ")"
    [128] AttribNameOrWildcard ::= AttributeName | "*"
    [135] AttributeName 	   ::= QName
    [137] TypeName 	           ::= QName
    ************************************************************************/
    final public AttributeTest parseAttributeTest() throws ParseException, XQueryException {
        QualifiedName attributeName = null;
        QualifiedName typeName = null;
        switch(jj_nt.kind) {
            case AttributeType:
                currentToken = jj_consume_token(AttributeType);
                break;
            case AttributeTypeForKindTest:
                currentToken = jj_consume_token(AttributeTypeForKindTest);
                break;
            default:
                jj_la1[52] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case AnyName:
            case QNameForItemType:
                switch(jj_nt.kind) {
                    case QNameForItemType:
                        currentToken = jj_consume_token(QNameForItemType);
                        attributeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                        break;
                    case AnyName:
                        currentToken = jj_consume_token(AnyName);
                        break;
                    default:
                        jj_la1[53] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch(jj_nt.kind) {
                    case CommaForKindTest:
                        currentToken = jj_consume_token(CommaForKindTest);
                        currentToken = jj_consume_token(QNameForItemType);
                        typeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                        break;
                    default:
                        jj_la1[54] = jj_gen;
                        ;
                }
                break;
            default:
                jj_la1[55] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(RparForKindTest);
        {
            if(true)
                return TypeFactory.createAttributeTest(attributeName, typeName);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [129] SchemaAttributeTest  ::= <"schema-attribute" "("> AttributeDeclaration ")"
    [130] AttributeDeclaration ::= AttributeName
    [135] AttributeName 	   ::= QName
    ************************************************************************/
    final public SchemaAttributeTest parseSchemaAttributeTest() throws ParseException,
            XQueryException {
        final QualifiedName attributeName;
        switch(jj_nt.kind) {
            case SchemaAttributeType:
                currentToken = jj_consume_token(SchemaAttributeType);
                break;
            case SchemaAttributeTypeForKindTest:
                currentToken = jj_consume_token(SchemaAttributeTypeForKindTest);
                break;
            default:
                jj_la1[56] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(QNameForItemType);
        attributeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
        currentToken = jj_consume_token(RparForKindTest);
        if(attributeName == null) {
            error("err:XPST0008");
        }
        {
            if(true)
                return TypeFactory.createSchemaAttributeTest(attributeName);
        }
        throw new Error("Missing return statement in function");
    }

    // ---------------------------------------------------------
    // Expressions entries (http://www.w3.org/TR/xquery/#id-expressions)

    /************************************************************************
    [31] Expr ::= ExprSingle ("," ExprSingle)*
    ************************************************************************/
    final public XQExpression parseExpr() throws ParseException, XQueryException {
        XQExpression expr = null;
        final List<XQExpression> exprs;
        expr = parseExprSingle();
        exprs = new LinkedList<XQExpression>();
        exprs.add(expr);
        label_6: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[57] = jj_gen;
                    break label_6;
            }
            currentToken = jj_consume_token(Comma);
            expr = parseExprSingle();
            exprs.add(expr);
        }
        if(expr == null) { // sanity check
            error("Invalid Expr.");
        } else {
            {
                if(true)
                    return ExpressionFactory.createExpression(exprs);
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [32] ExprSingle ::= FLWRExpr
    				| QuantifiedExpr
    				| TypeswitchExpr
    				| IfExpr
    				| OrExpr
    ************************************************************************/
    final public XQExpression parseExprSingle() throws ParseException, XQueryException {
        final XQExpression expr;
        switch(jj_nt.kind) {
            case ForVariable:
            case LetVariable:
                expr = parseFLWRExpr();
                break;
            case Some:
            case Every:
                expr = parseQuantifiedExpr();
                break;
            case TypeswitchLpar:
                expr = parseTypeswitchExpr();
                break;
            case IfLpar:
                expr = parseIfExpr();
                break;
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                expr = parseOrExpr();
                break;
            default:
                jj_la1[58] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [33] FLWRExpr 	   ::= (ForClause | LetClause)+ WhereClause? OrderByClause? "return" ExprSingle
    [33] FLWORExpr 	   ::= (ForClause | LetClause | WindowClause)+ WhereClause? (GroupByClause LetClause* WhereClause?)? OrderByClause? ReturnClause

    [34] ForClause 	   ::= <"for" "$"> VarName TypeDeclaration? PositionalVar? "in" ExprSingle 
    						 ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
    [36] LetClause 	   ::= <"let" "$"> VarName TypeDeclaration? ":=" ExprSingle 
    						 ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
    [37] WhereClause   ::= "where" ExprSingle
    [38] OrderByClause ::= (<"order" "by"> | <"stable" "order" "by">) OrderSpecList
    [39] OrderSpecList ::= OrderSpec ("," OrderSpec)*
    ************************************************************************/
    final public XQExpression parseFLWRExpr() throws ParseException, XQueryException {
        final FLWRExpr flower = new FLWRExpr();
        List<Binding> bindings = null;
        XQExpression whereExpr = null;
        OrderSpec order = null;
        XQExpression returnExpr = null;
        currentModule.pushVarScope();
        locate(flower);
        label_7: while(true) {
            switch(jj_nt.kind) {
                case ForVariable:
                    bindings = parseForClause();
                    break;
                case LetVariable:
                    bindings = parseLetClause();
                    break;
                default:
                    jj_la1[59] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            flower.addClauses(bindings);
            switch(jj_nt.kind) {
                case ForVariable:
                case LetVariable:
                    ;
                    break;
                default:
                    jj_la1[60] = jj_gen;
                    break label_7;
            }
        }
        switch(jj_nt.kind) {
            case Where:
                currentToken = jj_consume_token(Where);
                whereExpr = parseExprSingle();
                flower.setWhereExpr(whereExpr);
                break;
            default:
                jj_la1[61] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case GroupBy:
                Grouping grouping = null;
                grouping = parseGroupByClause();
                flower.setGroupByClause(grouping);
                label_8: while(true) {
                    switch(jj_nt.kind) {
                        case LetVariable:
                            ;
                            break;
                        default:
                            jj_la1[62] = jj_gen;
                            break label_8;
                    }
                    bindings = parseLetClause();
                    grouping.addLetClauses(bindings);
                }
                switch(jj_nt.kind) {
                    case Where:
                        currentToken = jj_consume_token(Where);
                        whereExpr = parseExprSingle();
                        grouping.setWhereExpression(whereExpr);
                        break;
                    default:
                        jj_la1[63] = jj_gen;
                        ;
                }
                break;
            default:
                jj_la1[64] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case OrderBy:
            case OrderByStable:
                switch(jj_nt.kind) {
                    case OrderBy:
                        currentToken = jj_consume_token(OrderBy);
                        break;
                    case OrderByStable:
                        currentToken = jj_consume_token(OrderByStable);
                        flower.setStableOrdering(true);
                        break;
                    default:
                        jj_la1[65] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                order = parseOrderSpec();
                flower.addOrderSpec(order);
                label_9: while(true) {
                    switch(jj_nt.kind) {
                        case Comma:
                            ;
                            break;
                        default:
                            jj_la1[66] = jj_gen;
                            break label_9;
                    }
                    currentToken = jj_consume_token(Comma);
                    order = parseOrderSpec();
                    flower.addOrderSpec(order);
                }
                break;
            default:
                jj_la1[67] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Return);
        returnExpr = parseExprSingle();
        flower.setReturnExpr(returnExpr);
        currentModule.popVarScope();
        {
            if(true)
                return flower.normalize();
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [34]  ForClause 	  ::= <"for" "$"> VarName TypeDeclaration? PositionalVar? "in" ExprSingle 
    						    ("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
    [144] VarName 	      ::= QName
    [116] TypeDeclaration ::= "as" SequenceType
    [35]  PositionalVar   ::= "at" "$" VarName
    ************************************************************************/
    final public List<Binding> parseForClause() throws ParseException, XQueryException {
        final List<Binding> fors;
        ForClause clause;
        ForVariable var;
        Type varType = null;
        XQExpression expr;
        currentToken = jj_consume_token(ForVariable);
        currentToken = jj_consume_token(VarName);
        QualifiedName varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
        var = new ForVariable(varName);
        currentModule.putVariable(varName, var);
        clause = new ForClause(var);
        locate(clause);
        switch(jj_nt.kind) {
            case As:
                //TypeDeclaration? 
                currentToken = jj_consume_token(As);
                varType = parseSequenceType();
                var.setType(varType);
                break;
            default:
                jj_la1[68] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case AtWord:
                //PositionalVar?
                currentToken = jj_consume_token(AtWord);
                currentToken = jj_consume_token(VariableIndicator);
                currentToken = jj_consume_token(VarName);
                QualifiedName posVarName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
                PositionalVariable posVar = new PositionalVariable(posVarName);
                currentModule.putVariable(posVarName, posVar);
                clause.setPositionVariable(posVar);
                break;
            default:
                jj_la1[69] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(In);
        expr = parseExprSingle();
        clause.setInExpr(expr);
        fors = new LinkedList<Binding>();
        fors.add(clause);
        label_10: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[70] = jj_gen;
                    break label_10;
            }
            //("," "$" VarName TypeDeclaration? PositionalVar? "in" ExprSingle)*
            currentToken = jj_consume_token(Comma);
            currentToken = jj_consume_token(VariableIndicator);
            currentToken = jj_consume_token(VarName);
            varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
            var = new ForVariable(varName);
            currentModule.putVariable(varName, var);
            clause = new ForClause(var);
            switch(jj_nt.kind) {
                case As:
                    //TypeDeclaration? 
                    currentToken = jj_consume_token(As);
                    varType = parseSequenceType();
                    var.setType(varType);
                    break;
                default:
                    jj_la1[71] = jj_gen;
                    ;
            }
            switch(jj_nt.kind) {
                case AtWord:
                    //PositionalVar?
                    currentToken = jj_consume_token(AtWord);
                    currentToken = jj_consume_token(VariableIndicator);
                    currentToken = jj_consume_token(VarName);
                    QualifiedName posVarName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
                    PositionalVariable posVar = new PositionalVariable(posVarName);
                    currentModule.putVariable(posVarName, posVar);
                    clause.setPositionVariable(posVar);
                    break;
                default:
                    jj_la1[72] = jj_gen;
                    ;
            }
            currentToken = jj_consume_token(In);
            expr = parseExprSingle();
            clause.setInExpr(expr);
            fors.add(clause);
        }
        {
            if(true)
                return fors;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [36] LetClause ::= <"let" "$"> VarName TypeDeclaration? ":=" ExprSingle 
    					 ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
    [110] TypeDeclaration ::= "as" SequenceType
    ************************************************************************/
    final public List<Binding> parseLetClause() throws ParseException, XQueryException {
        final List<Binding> lets;
        LetVariable var;
        LetClause clause;
        Type varType = null;
        XQExpression expr = null;
        currentToken = jj_consume_token(LetVariable);
        currentToken = jj_consume_token(VarName);
        QualifiedName varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
        var = new LetVariable(varName);
        currentModule.putVariable(varName, var);
        clause = new LetClause(var);
        locate(clause);
        switch(jj_nt.kind) {
            case As:
                currentToken = jj_consume_token(As);
                varType = parseSequenceType();
                var.setType(varType);
                break;
            default:
                jj_la1[73] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(ColonEquals);
        expr = parseExprSingle();
        var.setValue(expr);
        lets = new LinkedList<Binding>();
        lets.add(clause);
        label_11: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[74] = jj_gen;
                    break label_11;
            }
            //("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
            currentToken = jj_consume_token(Comma);
            currentToken = jj_consume_token(VariableIndicator);
            currentToken = jj_consume_token(VarName);
            varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
            var = new LetVariable(varName);
            currentModule.putVariable(varName, var);
            clause = new LetClause(var);
            switch(jj_nt.kind) {
                case As:
                    currentToken = jj_consume_token(As);
                    varType = parseSequenceType();
                    var.setType(varType);
                    break;
                default:
                    jj_la1[75] = jj_gen;
                    ;
            }
            currentToken = jj_consume_token(ColonEquals);
            expr = parseExprSingle();
            var.setValue(expr);
            lets.add(clause);
        }
        {
            if(true)
                return lets;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [47] GroupByClause 	  ::= "group" "by" GroupingSpecList
    [48] GroupingSpecList ::= GroupingSpec ("," GroupingSpec)*
    ************************************************************************/
    final public Grouping parseGroupByClause() throws ParseException, XQueryException {
        final Grouping grouping = new Grouping();
        GroupingSpec spec = null;
        currentToken = jj_consume_token(GroupBy);
        //GroupingSpecList
        spec = parseGroupingSpec();
        grouping.addGroupingKey(spec);
        label_12: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[76] = jj_gen;
                    break label_12;
            }
            currentToken = jj_consume_token(Comma);
            spec = parseGroupingSpec();
            grouping.addGroupingKey(spec);
        }
        locate(grouping);
        {
            if(true)
                return grouping;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [49] GroupingSpec 	  ::= "$" VarName ("collation" URILiteral)?
    ************************************************************************/
    final public GroupingSpec parseGroupingSpec() throws ParseException, XQueryException {
        final GroupingSpec spec;
        currentToken = jj_consume_token(VariableIndicator);
        currentToken = jj_consume_token(VarName);
        String defaultNamespace = currentModule.getNamespace();
        if(defaultNamespace == null) {
            defaultNamespace = "";
        }
        QualifiedName vn = QNameUtil.parse(currentToken.image, namespaceContext, defaultNamespace);
        Variable var = currentModule.getVariable(vn);
        if(var == null) {
            error("err:XPST0008");
        }
        if(!(var instanceof ForVariable || var instanceof LetVariable)) {
            error("err:XQST0094");
        }
        VarRef ref = new VarRef(var);
        spec = new GroupingSpec(ref);
        locate(spec);
        switch(jj_nt.kind) {
            case Collation:
                // ("collation" URILiteral)?
                currentToken = jj_consume_token(Collation);
                currentToken = jj_consume_token(URILiteralToOperator);
                String collation = unquote(currentToken.image);
                if(collation != null) {
                    try {
                        URI url = new URI(collation);
                        spec.setCollation(url);
                    } catch (URISyntaxException e) {
                        error("err:XQST0046");
                    }
                }
                break;
            default:
                jj_la1[77] = jj_gen;
                ;
        }
        {
            if(true)
                return spec;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [40] OrderSpec 	   ::=  ExprSingle OrderModifier
    [41] OrderModifier ::= ("ascending" | "descending")? (<"empty" "greatest"> | <"empty" "least">)? ("collation" URILiteral)?
    ************************************************************************/
    final public OrderSpec parseOrderSpec() throws ParseException, XQueryException {
        final OrderSpec spec;
        final XQExpression keyExpr;
        String collation = null;
        keyExpr = parseExprSingle();
        spec = new OrderSpec(keyExpr);
        locate(spec);
        switch(jj_nt.kind) {
            case Ascending:
            case Descending:
                switch(jj_nt.kind) {
                    case Ascending:
                        currentToken = jj_consume_token(Ascending);
                        break;
                    case Descending:
                        currentToken = jj_consume_token(Descending);
                        spec.setDescending(true);
                        break;
                    default:
                        jj_la1[78] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[79] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case EmptyGreatest:
            case EmptyLeast:
                switch(jj_nt.kind) {
                    case EmptyGreatest:
                        currentToken = jj_consume_token(EmptyGreatest);
                        spec.setEmptyGreatest(true);
                        break;
                    case EmptyLeast:
                        currentToken = jj_consume_token(EmptyLeast);
                        break;
                    default:
                        jj_la1[80] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[81] = jj_gen;
                ;
        }
        switch(jj_nt.kind) {
            case Collation:
                currentToken = jj_consume_token(Collation);
                currentToken = jj_consume_token(URILiteralToOperator);
                collation = unquote(currentToken.image);
                if(collation != null) {
                    try {
                        URI url = new URI(collation);
                        spec.setCollation(url);
                    } catch (URISyntaxException e) {
                        error("err:XQST0046");
                    }
                }
                break;
            default:
                jj_la1[82] = jj_gen;
                ;
        }
        {
            if(true)
                return spec;
        }
        throw new Error("Missing return statement in function");
    }

    // ---------------------------------------------------------
    // 3.11 Quantified Expressions

    /************************************************************************
    [42] QuantifiedExpr ::= (<"some" "$"> | <"every" "$">) VarName TypeDeclaration? "in" ExprSingle 
    			   								  ("," "$" VarName TypeDeclaration? "in" ExprSingle)*
    						"satisfies" ExprSingle
    [137] VarName ::= QName
    [110] TypeDeclaration ::= "as" SequenceType
    *************************************************************************/
    final public QuantifiedExpr parseQuantifiedExpr() throws ParseException, XQueryException {
        final QuantifiedExpr outermost;
        boolean isEveryQuantifier = false;
        QualifiedName varName;
        QuantifiedVariable var;
        Type varType = null;
        XQExpression valueExpr;
        final XQExpression condExpr;
        currentModule.pushVarScope();
        switch(jj_nt.kind) {
            case Some:
                currentToken = jj_consume_token(Some);
                break;
            case Every:
                currentToken = jj_consume_token(Every);
                isEveryQuantifier = true;
                break;
            default:
                jj_la1[83] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(VarName);
        varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
        var = new QuantifiedVariable(varName);
        currentModule.putVariable(varName, var);
        switch(jj_nt.kind) {
            case As:
                currentToken = jj_consume_token(As);
                varType = parseSequenceType();
                var.setType(varType);
                break;
            default:
                jj_la1[84] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(In);
        valueExpr = parseExprSingle();
        var.setValue(valueExpr);
        outermost = new QuantifiedExpr(isEveryQuantifier, var);
        QuantifiedExpr outer = outermost;
        label_13: while(true) {
            switch(jj_nt.kind) {
                case Comma:
                    ;
                    break;
                default:
                    jj_la1[85] = jj_gen;
                    break label_13;
            }
            currentToken = jj_consume_token(Comma);
            currentToken = jj_consume_token(VariableIndicator);
            currentToken = jj_consume_token(VarName);
            varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
            var = new QuantifiedVariable(varName);
            currentModule.putVariable(varName, var);
            switch(jj_nt.kind) {
                case As:
                    currentToken = jj_consume_token(As);
                    varType = parseSequenceType();
                    var.setType(varType);
                    break;
                default:
                    jj_la1[86] = jj_gen;
                    ;
            }
            currentToken = jj_consume_token(In);
            valueExpr = parseExprSingle();
            var.setValue(valueExpr);
            QuantifiedExpr inner = new QuantifiedExpr(isEveryQuantifier, var);
            outer.setCondExpr(inner);
            outer = inner;
        }
        currentToken = jj_consume_token(Satisfies);
        condExpr = parseExprSingle();
        assert (outer.getCondExpr() == null);
        outer.setCondExpr(condExpr);
        currentModule.popVarScope();
        {
            if(true)
                return outermost;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [43] TypeswitchExpr ::= <"typeswitch" "("> Expr ")" CaseClause+
    						"default" ("$" VarName)? "return" ExprSingle
    ************************************************************************/
    final public TypeswitchExpr parseTypeswitchExpr() throws ParseException, XQueryException {
        final TypeswitchExpr switchExpr;
        XQExpression expr = null;
        CaseClause cc = null;
        QualifiedName varName = null;
        currentToken = jj_consume_token(TypeswitchLpar);
        expr = parseExpr();
        switchExpr = new TypeswitchExpr(expr);
        locate(switchExpr);
        currentToken = jj_consume_token(Rpar);
        label_14: while(true) {
            cc = parseCaseClause();
            switchExpr.addCaseClause(cc);
            switch(jj_nt.kind) {
                case Case:
                    ;
                    break;
                default:
                    jj_la1[87] = jj_gen;
                    break label_14;
            }
        }
        currentModule.pushVarScope();
        currentToken = jj_consume_token(Default);
        switch(jj_nt.kind) {
            case VariableIndicator:
                currentToken = jj_consume_token(VariableIndicator);
                currentToken = jj_consume_token(VarName);
                varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
                break;
            default:
                jj_la1[88] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Return);
        expr = parseExprSingle();
        CaseVariable var = new CaseVariable(varName);
        CaseClause dc = new CaseClause(var, expr);
        switchExpr.setDefaultClause(dc);
        currentModule.popVarScope();
        {
            if(true)
                return switchExpr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [44] CaseClause 	::= "case" ("$" VarName "as")? SequenceType "return" ExprSingle
    ************************************************************************/
    final public CaseClause parseCaseClause() throws ParseException, XQueryException {
        QualifiedName varName = null;
        CaseVariable caseVar = null;
        final Type varType;
        final XQExpression retExpr;
        currentModule.pushVarScope();
        currentToken = jj_consume_token(Case);
        switch(jj_nt.kind) {
            case VariableIndicator:
                // ("$" VarName "as")?
                currentToken = jj_consume_token(VariableIndicator);
                currentToken = jj_consume_token(VarName);
                varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
                caseVar = new CaseVariable(varName);
                currentModule.putVariable(varName, caseVar);
                currentToken = jj_consume_token(As);
                break;
            default:
                jj_la1[89] = jj_gen;
                ;
        }
        if(caseVar == null) {
            caseVar = new CaseVariable(null);
        }
        varType = parseSequenceType();
        caseVar.setType(varType);
        currentToken = jj_consume_token(Return);
        retExpr = parseExprSingle();
        currentModule.popVarScope();
        final CaseClause cc = new CaseClause(caseVar, retExpr);
        locate(cc);
        {
            if(true)
                return cc;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [45] IfExpr ::= "if" "(" Expr ")" "then" ExprSingle "else" ExprSingle
    ************************************************************************/
    final public IfExpr parseIfExpr() throws ParseException, XQueryException {
        final XQExpression condExpr, thenExpr, elseExpr;
        currentToken = jj_consume_token(IfLpar);
        condExpr = parseExpr();
        currentToken = jj_consume_token(Rpar);
        currentToken = jj_consume_token(Then);
        thenExpr = parseExprSingle();
        currentToken = jj_consume_token(Else);
        elseExpr = parseExprSingle();
        final IfExpr expr = new IfExpr(condExpr, thenExpr, elseExpr);
        locate(expr);
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [46] OrExpr 	   ::=    	AndExpr ( "or" AndExpr )*
    ************************************************************************/
    final public XQExpression parseOrExpr() throws ParseException, XQueryException {
        XQExpression expr;
        final List<XQExpression> exprs = new LinkedList<XQExpression>();
        expr = parseAndExpr();
        exprs.add(expr);
        label_15: while(true) {
            switch(jj_nt.kind) {
                case Or:
                    ;
                    break;
                default:
                    jj_la1[90] = jj_gen;
                    break label_15;
            }
            currentToken = jj_consume_token(Or);
            expr = parseAndExpr();
            exprs.add(expr);
        }
        if(exprs.size() == 1) {
            {
                if(true)
                    return exprs.get(0);
            }
        } else {
            {
                if(true)
                    return locate(new OrExpr(exprs));
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [47] AndExpr 	   ::=    	ComparisonExpr ( "and" ComparisonExpr )*
    ************************************************************************/
    final public XQExpression parseAndExpr() throws ParseException, XQueryException {
        XQExpression expr;
        final List<XQExpression> exprs = new LinkedList<XQExpression>();
        expr = parseComparisonExpr();
        exprs.add(expr);
        label_16: while(true) {
            switch(jj_nt.kind) {
                case And:
                    ;
                    break;
                default:
                    jj_la1[91] = jj_gen;
                    break label_16;
            }
            currentToken = jj_consume_token(And);
            expr = parseComparisonExpr();
            exprs.add(expr);
        }
        if(exprs.size() == 1) {
            {
                if(true)
                    return exprs.get(0);
            }
        } else {
            {
                if(true)
                    return locate(new AndExpr(exprs));
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [48] ComparisonExpr ::=    	RangeExpr ( (ValueComp | GeneralComp | NodeComp) RangeExpr )?
    [61] ValueComp 	    ::=    	"eq" | "ne" | "lt" | "le" | "gt" | "ge"
    [60] GeneralComp 	::=    	"=" | "!=" | "<" | "<=" | ">" | ">="
    [62] NodeComp 	    ::=    	"is" | "<<" | ">>"
    ************************************************************************/
    final public XQExpression parseComparisonExpr() throws ParseException, XQueryException {
        XQExpression expr;
        XQExpression rightExpr = null;
        expr = parseRangeExpr();
        switch(jj_nt.kind) {
            case Equals:
            case FortranEq:
            case FortranGe:
            case FortranGt:
            case FortranLe:
            case FortranLt:
            case FortranNe:
            case GtEquals:
            case GtGt:
            case Gt:
            case Is:
            case LtEquals:
            case LtLt:
            case Lt:
            case NotEquals:
                final ComparisonOp op;
                switch(jj_nt.kind) {
                    case FortranEq:
                    case FortranGe:
                    case FortranGt:
                    case FortranLe:
                    case FortranLt:
                    case FortranNe:
                        final ValueComp.Operator vcmp;
                        switch(jj_nt.kind) {
                            case FortranEq:
                                // "eq" | "ne" | "lt" | "le" | "gt" | "ge"	
                                currentToken = jj_consume_token(FortranEq);
                                vcmp = ValueComp.Operator.EQ;
                                break;
                            case FortranNe:
                                currentToken = jj_consume_token(FortranNe);
                                vcmp = ValueComp.Operator.NE;
                                break;
                            case FortranLt:
                                currentToken = jj_consume_token(FortranLt);
                                vcmp = ValueComp.Operator.LT;
                                break;
                            case FortranLe:
                                currentToken = jj_consume_token(FortranLe);
                                vcmp = ValueComp.Operator.LE;
                                break;
                            case FortranGt:
                                currentToken = jj_consume_token(FortranGt);
                                vcmp = ValueComp.Operator.GT;
                                break;
                            case FortranGe:
                                currentToken = jj_consume_token(FortranGe);
                                vcmp = ValueComp.Operator.GE;
                                break;
                            default:
                                jj_la1[92] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        op = new ValueComp(vcmp, expr);
                        break;
                    case Equals:
                    case GtEquals:
                    case Gt:
                    case LtEquals:
                    case Lt:
                    case NotEquals:
                        final GeneralComp.Operator gcmp;
                        switch(jj_nt.kind) {
                            case Equals:
                                // "=" | "!=" | "<" | "<=" | ">" | ">="
                                currentToken = jj_consume_token(Equals);
                                gcmp = GeneralComp.Operator.EQ;
                                break;
                            case NotEquals:
                                currentToken = jj_consume_token(NotEquals);
                                gcmp = GeneralComp.Operator.NE;
                                break;
                            case Lt:
                                currentToken = jj_consume_token(Lt);
                                gcmp = GeneralComp.Operator.LT;
                                break;
                            case LtEquals:
                                currentToken = jj_consume_token(LtEquals);
                                gcmp = GeneralComp.Operator.LE;
                                break;
                            case Gt:
                                currentToken = jj_consume_token(Gt);
                                gcmp = GeneralComp.Operator.GT;
                                break;
                            case GtEquals:
                                currentToken = jj_consume_token(GtEquals);
                                gcmp = GeneralComp.Operator.GE;
                                break;
                            default:
                                jj_la1[93] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        op = new GeneralComp(gcmp, expr);
                        break;
                    case GtGt:
                    case Is:
                    case LtLt:
                        final NodeComp.Operator ncmp;
                        switch(jj_nt.kind) {
                            case Is:
                                // "is" | "<<" | ">>"
                                currentToken = jj_consume_token(Is);
                                ncmp = NodeComp.Operator.IS;
                                break;
                            case LtLt:
                                currentToken = jj_consume_token(LtLt);
                                ncmp = NodeComp.Operator.PRECEDES;
                                break;
                            case GtGt:
                                currentToken = jj_consume_token(GtGt);
                                ncmp = NodeComp.Operator.FOLLOWS;
                                break;
                            default:
                                jj_la1[94] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        op = new NodeComp(ncmp, expr);
                        break;
                    default:
                        jj_la1[95] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                rightExpr = parseRangeExpr();
                op.setRightOperand(rightExpr);
                expr = locate(op);
                break;
            default:
                jj_la1[96] = jj_gen;
                ;
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [49] RangeExpr ::= AdditiveExpr ( "to" AdditiveExpr )?
    ************************************************************************/
    final public XQExpression parseRangeExpr() throws ParseException, XQueryException {
        final XQExpression e1;
        XQExpression e2 = null;
        e1 = parseAdditiveExpr();
        switch(jj_nt.kind) {
            case To:
                currentToken = jj_consume_token(To);
                e2 = parseAdditiveExpr();
                break;
            default:
                jj_la1[97] = jj_gen;
                ;
        }
        if(e2 == null) {
            {
                if(true)
                    return e1;
            }
        } else {
            {
                if(true)
                    return locate(new RangeExpr(e1, e2));
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [50] AdditiveExpr  		::= MultiplicativeExpr ( ("+" | "-") MultiplicativeExpr )*
    ************************************************************************/
    final public XQExpression parseAdditiveExpr() throws ParseException, XQueryException {
        XQExpression e1;
        XQExpression e2 = null;
        boolean isPlus = true;
        e1 = parseMultiplicativeExpr();
        label_17: while(true) {
            switch(jj_nt.kind) {
                case Plus:
                case Minus:
                    ;
                    break;
                default:
                    jj_la1[98] = jj_gen;
                    break label_17;
            }
            switch(jj_nt.kind) {
                case Plus:
                    currentToken = jj_consume_token(Plus);
                    isPlus = true;
                    break;
                case Minus:
                    currentToken = jj_consume_token(Minus);
                    isPlus = false;
                    break;
                default:
                    jj_la1[99] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            e2 = parseMultiplicativeExpr();
            e1 = locate(new AdditiveExpr(isPlus, e1, e2));
        }
        {
            if(true)
                return e1;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [51] MultiplicativeExpr ::= UnionExpr ( ("*" | "div" | "idiv" | "mod") UnionExpr )*
    ************************************************************************/
    final public XQExpression parseMultiplicativeExpr() throws ParseException, XQueryException {
        XQExpression e1;
        String operator = null;
        XQExpression e2 = null;
        e1 = parseUnionExpr();
        label_18: while(true) {
            switch(jj_nt.kind) {
                case Div:
                case Idiv:
                case Mod:
                case Multiply:
                    ;
                    break;
                default:
                    jj_la1[100] = jj_gen;
                    break label_18;
            }
            switch(jj_nt.kind) {
                case Multiply:
                    currentToken = jj_consume_token(Multiply);
                    operator = MultiplicativeExpr.MULTIPLY;
                    break;
                case Div:
                    currentToken = jj_consume_token(Div);
                    operator = MultiplicativeExpr.DIV;
                    break;
                case Idiv:
                    currentToken = jj_consume_token(Idiv);
                    operator = MultiplicativeExpr.IDIV;
                    break;
                case Mod:
                    currentToken = jj_consume_token(Mod);
                    operator = MultiplicativeExpr.MOD;
                    break;
                default:
                    jj_la1[101] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            e2 = parseUnionExpr();
            e1 = locate(new MultiplicativeExpr(operator, e1, e2));
        }
        {
            if(true)
                return e1;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [52] UnionExpr ::= IntersectExceptExpr ( ("union" | "|") IntersectExceptExpr )*
    ************************************************************************/
    final public XQExpression parseUnionExpr() throws ParseException, XQueryException {
        XQExpression e1;
        XQExpression e2 = null;
        e1 = parseIntersectExceptExpr();
        label_19: while(true) {
            switch(jj_nt.kind) {
                case Union:
                case Vbar:
                    ;
                    break;
                default:
                    jj_la1[102] = jj_gen;
                    break label_19;
            }
            switch(jj_nt.kind) {
                case Union:
                    currentToken = jj_consume_token(Union);
                    break;
                case Vbar:
                    currentToken = jj_consume_token(Vbar);
                    break;
                default:
                    jj_la1[103] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            e2 = parseIntersectExceptExpr();
            e1 = locate(new UnionOp(e1, e2));
        }
        {
            if(true)
                return e1;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [53] IntersectExceptExpr ::= InstanceofExpr ( ("intersect" | "except") InstanceofExpr )*
    ************************************************************************/
    final public XQExpression parseIntersectExceptExpr() throws ParseException, XQueryException {
        XQExpression e1;
        boolean isExcept = false;
        XQExpression e2 = null;
        e1 = parseInstanceofExpr();
        label_20: while(true) {
            switch(jj_nt.kind) {
                case Except:
                case Intersect:
                    ;
                    break;
                default:
                    jj_la1[104] = jj_gen;
                    break label_20;
            }
            switch(jj_nt.kind) {
                case Intersect:
                    currentToken = jj_consume_token(Intersect);
                    isExcept = false;
                    break;
                case Except:
                    currentToken = jj_consume_token(Except);
                    isExcept = true;
                    break;
                default:
                    jj_la1[105] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            e2 = parseInstanceofExpr();
            if(isExcept) {
                e1 = locate(new ExceptOp(e1, e2));
            } else {
                e1 = locate(new IntersectOp(e1, e2));
            }
        }
        {
            if(true)
                return e1;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [54] InstanceofExpr ::= TreatExpr ( "instance" "of" SequenceType )?
    ************************************************************************/
    final public XQExpression parseInstanceofExpr() throws ParseException, XQueryException {
        XQExpression expr;
        Type type = null;
        expr = parseTreatExpr();
        switch(jj_nt.kind) {
            case Instanceof:
                currentToken = jj_consume_token(Instanceof);
                type = parseSequenceType();
                expr = locate(new InstanceofOp(expr, type));
                break;
            default:
                jj_la1[106] = jj_gen;
                ;
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [55] TreatExpr ::= CastableExpr ( "treat" "as" SequenceType )?
    ************************************************************************/
    final public XQExpression parseTreatExpr() throws ParseException, XQueryException {
        XQExpression expr;
        Type type = null;
        expr = parseCastableExpr();
        switch(jj_nt.kind) {
            case TreatAs:
                currentToken = jj_consume_token(TreatAs);
                type = parseSequenceType();
                expr = locate(new TreatExpr(expr, type));
                break;
            default:
                jj_la1[107] = jj_gen;
                ;
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [56]  CastableExpr ::= CastExpr ( "castable" "as" SingleType )?
    [115] SingleType   ::= AtomicType "?"?
    [120] AtomicType   ::= QName
    ************************************************************************/
    final public XQExpression parseCastableExpr() throws ParseException, XQueryException {
        XQExpression expr;
        expr = parseCastExpr();
        switch(jj_nt.kind) {
            case Castable:
                currentToken = jj_consume_token(Castable);
                switch(jj_nt.kind) {
                    case QNameForAtomicType:
                        currentToken = jj_consume_token(QNameForAtomicType);
                        break;
                    case QNameForSequenceType:
                        currentToken = jj_consume_token(QNameForSequenceType);
                        break;
                    default:
                        jj_la1[108] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                QualifiedName typeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                Type type = TypeFactory.createAtomicType(typeName, staticContext);
                switch(jj_nt.kind) {
                    case OccurrenceZeroOrOne:
                        currentToken = jj_consume_token(OccurrenceZeroOrOne);
                        type = TypeFactory.createSequenceType((AtomicType) type, Occurrence.OCC_ZERO_OR_ONE);
                        break;
                    default:
                        jj_la1[109] = jj_gen;
                        ;
                }
                expr = locate(new CastableExpr(expr, type));
                break;
            default:
                jj_la1[110] = jj_gen;
                ;
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [57] CastExpr ::= UnaryExpr ( "cast" "as" SingleType )?
    [115] SingleType   ::= AtomicType "?"?
    [120] AtomicType   ::= QName
    ************************************************************************/
    final public XQExpression parseCastExpr() throws ParseException, XQueryException {
        XQExpression expr;
        expr = parseUnaryExpr();
        switch(jj_nt.kind) {
            case CastAs:
                currentToken = jj_consume_token(CastAs);
                switch(jj_nt.kind) {
                    case QNameForAtomicType:
                        currentToken = jj_consume_token(QNameForAtomicType);
                        break;
                    case QNameForSequenceType:
                        currentToken = jj_consume_token(QNameForSequenceType);
                        break;
                    default:
                        jj_la1[111] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                QualifiedName typeName = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                Type type = TypeFactory.createAtomicType(typeName, staticContext);
                switch(jj_nt.kind) {
                    case OccurrenceZeroOrOne:
                        currentToken = jj_consume_token(OccurrenceZeroOrOne);
                        type = TypeFactory.createSequenceType((AtomicType) type, Occurrence.OCC_ZERO_OR_ONE);
                        break;
                    default:
                        jj_la1[112] = jj_gen;
                        ;
                }
                expr = locate(new CastExpr(expr, type));
                break;
            default:
                jj_la1[113] = jj_gen;
                ;
        }
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [58] UnaryExpr ::= ("-" | "+")* ValueExpr
    [59] ValueExpr ::= ValidateExpr | PathExpr | ExtensionExpr
    [64] ExtensionExpr ::= Pragma+ "{" Expr? "}"
    ************************************************************************/
    final public XQExpression parseUnaryExpr() throws ParseException, XQueryException {
        boolean isMinus = false;
        final XQExpression valueExpr;
        label_21: while(true) {
            switch(jj_nt.kind) {
                case Plus:
                case Minus:
                    ;
                    break;
                default:
                    jj_la1[114] = jj_gen;
                    break label_21;
            }
            switch(jj_nt.kind) {
                case Minus:
                    currentToken = jj_consume_token(Minus);
                    isMinus = !isMinus;
                    break;
                case Plus:
                    currentToken = jj_consume_token(Plus);
                    break;
                default:
                    jj_la1[115] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        switch(jj_nt.kind) {
            case ValidateLbrace:
            case ValidateSchemaMode:
                valueExpr = parseValidateExpr();
                break;
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                valueExpr = parsePathExpr();
                break;
            case PragmaOpen:
                valueExpr = parseExtensionExpr();
                break;
            default:
                jj_la1[116] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if(isMinus) {
            {
                if(true)
                    return locate(new NegativeExpr(valueExpr));
            }
        } else {
            {
                if(true)
                    return valueExpr;
            }
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [63]  ValidateExpr 	   ::= 	(<"validate" "{"> | (<"validate" ValidationMode> "{")) Expr "}"
    [145] ValidationMode   ::= "lax" | "strict"
    ************************************************************************/
    final public ValidateOp parseValidateExpr() throws ParseException, XQueryException {
        final XQExpression expr;
        boolean isStrict = true;
        switch(jj_nt.kind) {
            case ValidateLbrace:
                currentToken = jj_consume_token(ValidateLbrace);
                break;
            case ValidateSchemaMode:
                currentToken = jj_consume_token(ValidateSchemaMode);
                if(currentToken.image.indexOf("lax") != -1) {
                    isStrict = false;
                }
                currentToken = jj_consume_token(LbraceExprEnclosure);
                break;
            default:
                jj_la1[117] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        expr = parseExpr();
        currentToken = jj_consume_token(Rbrace);
        final ValidateOp vop = new ValidateOp(expr, isStrict);
        locate(vop);
        {
            if(true)
                return vop;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [67] PathExpr ::= ("/" RelativePathExpr?)
    				| ("//" RelativePathExpr)
    				| RelativePathExpr
    ************************************************************************/
    final public XQExpression parsePathExpr() throws ParseException, XQueryException {
        final XQExpression expr;
        List<XQExpression> steps = null;
        switch(jj_nt.kind) {
            case Slash:
                currentToken = jj_consume_token(Slash);
                switch(jj_nt.kind) {
                    case DecimalLiteral:
                    case DotDot:
                    case Dot:
                    case DoubleLiteral:
                    case IntegerLiteral:
                    case XmlCommentStart:
                    case ProcessingInstructionStart:
                    case StartTagOpenRoot:
                    case TypeswitchLpar:
                    case ElementLbrace:
                    case AttributeLbrace:
                    case AttributeQNameLbrace:
                    case ElementQNameLbrace:
                    case DocumentLbrace:
                    case TextLbrace:
                    case PILbrace:
                    case PINCNameLbrace:
                    case CommentLbrace:
                    case OrderedOpen:
                    case UnorderedOpen:
                    case ExecuteAt:
                    case IfLpar:
                    case AxisAncestorOrSelf:
                    case AxisAncestor:
                    case AxisAttribute:
                    case AxisChild:
                    case AxisDescendantOrSelf:
                    case AxisDescendant:
                    case AxisFollowingSibling:
                    case AxisFollowing:
                    case AxisParent:
                    case AxisPrecedingSibling:
                    case AxisPreceding:
                    case AxisSelf:
                    case At:
                    case ElementType:
                    case AttributeType:
                    case SchemaElementType:
                    case SchemaAttributeType:
                    case CommentLparRpar:
                    case TextLparRpar:
                    case NodeLparRpar:
                    case DocumentLpar:
                    case ProcessingInstructionLpar:
                    case NCNameColonStar:
                    case StarColonNCName:
                    case QNameLpar:
                    case StringLiteral:
                    case Star:
                    case VariableIndicator:
                    case Lpar:
                    case ElementTypeForKindTest:
                    case AttributeTypeForKindTest:
                    case SchemaElementTypeForKindTest:
                    case SchemaAttributeTypeForKindTest:
                    case CommentLparRparForKindTest:
                    case TextLparRparForKindTest:
                    case NodeLparRparForKindTest:
                    case DocumentLparForKindTest:
                    case ProcessingInstructionLparForKindTest:
                    case ElementTypeForDocumentTest:
                    case SchemaElementTypeForDocumentTest:
                    case QName:
                    case XmlCommentStartForElementContent:
                    case ProcessingInstructionStartForElementContent:
                    case StartTagOpen:
                        steps = parseRelativePathExpr();
                        break;
                    default:
                        jj_la1[118] = jj_gen;
                        ;
                }
                expr = new AbsolutePath(steps);
                break;
            case SlashSlash:
                currentToken = jj_consume_token(SlashSlash);
                steps = parseRelativePathExpr();
                expr = new AbsolutePath(steps, true);
                break;
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                steps = parseRelativePathExpr();
                if(steps.size() == 1 && !(steps instanceof StepExpr)) {
                    expr = steps.get(0);
                } else {
                    expr = new RelativePath(steps);
                }
                break;
            default:
                jj_la1[119] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return locate(expr);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [68] RelativePathExpr ::=  StepExpr (("/" | "//") StepExpr)*
    ************************************************************************/
    final public List<XQExpression> parseRelativePathExpr() throws ParseException, XQueryException {
        final List<XQExpression> steps = new LinkedList<XQExpression>();
        XQExpression expr;
        expr = parseStepExpr();
        steps.add(expr);
        label_22: while(true) {
            switch(jj_nt.kind) {
                case SlashSlash:
                case Slash:
                    ;
                    break;
                default:
                    jj_la1[120] = jj_gen;
                    break label_22;
            }
            switch(jj_nt.kind) {
                case Slash:
                    currentToken = jj_consume_token(Slash);
                    break;
                case SlashSlash:
                    currentToken = jj_consume_token(SlashSlash);
                    steps.add(locate(new DescendantOrSelfStep.RootDescStep()));
                    break;
                default:
                    jj_la1[121] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            expr = parseStepExpr();
            steps.add(locate(expr));
        }
        {
            if(true)
                return steps;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [64] ExtensionExpr  ::= Pragma+ "{" Expr? "}"
    [65] Pragma 	    ::= "(#" S? QName PragmaContents "#)"
    [66] PragmaContents ::= (Char* - (Char* '#)' Char*))
    ************************************************************************/
    final public ExtensionExpr parseExtensionExpr() throws ParseException, XQueryException {
        final List<Pragma> pragmas = new LinkedList<Pragma>();
        QualifiedName pragma;
        XQExpression expr = null;
        label_23: while(true) {
            currentToken = jj_consume_token(PragmaOpen);
            switch(jj_nt.kind) {
                case S:
                    currentToken = jj_consume_token(S);
                    break;
                default:
                    jj_la1[122] = jj_gen;
                    ;
            }
            currentToken = jj_consume_token(QNameForPragma);
            pragma = QNameUtil.parse(currentToken.image, namespaceContext, null);
            StringBuilder buf = new StringBuilder();
            switch(jj_nt.kind) {
                case PragmaContents:
                    currentToken = jj_consume_token(PragmaContents);
                    buf.append(currentToken.image);
                    break;
                default:
                    jj_la1[123] = jj_gen;
                    ;
            }
            String content = buf.toString().trim();
            if(content.indexOf("#)") != -1) {
                error("err:XQST0013"); // Invalid pragma content
            }
            Pragma p = new Pragma(pragma, content);
            pragmas.add(p);
            currentToken = jj_consume_token(PragmaClose);
            if(jj_2_1(5)) {
                ;
            } else {
                break label_23;
            }
        }
        currentToken = jj_consume_token(LbraceExprEnclosure);
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case Some:
            case Every:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                expr = parseExpr();
                break;
            default:
                jj_la1[124] = jj_gen;
                ;
        }
        if(expr == null) {
            error("err:XQST0079"); // expression is absent
        }
        currentToken = jj_consume_token(Rbrace);
        final ExtensionExpr ee = new ExtensionExpr(expr, pragmas);
        locate(ee);
        {
            if(true)
                return ee;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [69] StepExpr	   ::= AxisStep | FilterExpr
    [70] AxisStep	   ::= (ReverseStep | ForwardStep) PredicateList
    [81] PredicateList ::= Predicate*
    [82] Predicate 	   ::= "[" Expr "]"
    [80] FilterExpr    ::= PrimaryExpr PredicateList
    ************************************************************************/
    final public XQExpression parseStepExpr() throws ParseException, XQueryException {
        XQExpression expr;
        XQExpression predicate = null;
        switch(jj_nt.kind) {
            case DotDot:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
                expr = parseReverseStep();
                break;
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case Star:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
                expr = parseForwardStep();
                break;
            case DecimalLiteral:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case QNameLpar:
            case StringLiteral:
            case VariableIndicator:
            case Lpar:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                expr = parsePrimaryExpr();
                break;
            default:
                jj_la1[125] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        label_24: while(true) {
            switch(jj_nt.kind) {
                case Lbrack:
                    ;
                    break;
                default:
                    jj_la1[126] = jj_gen;
                    break label_24;
            }
            //Predicate*
            currentToken = jj_consume_token(Lbrack);
            predicate = parseExpr();
            currentToken = jj_consume_token(Rbrack);
            FilterExpr filter = new FilterExpr(expr);
            filter.addPredicate(predicate);
            expr = filter;
        }
        {
            if(true)
                return locate(expr);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [71] ForwardStep ::= (ForwardAxis NodeTest) | AbbrevForwardStep
    [72] ForwardAxis ::=  ("child" "::")
    					| ("descendant" "::")
    					| ("attribute" "::")
    					| ("self" "::")
    					| ("descendant-or-self" "::")
    					| ("following-sibling" "::")
    					| ("following" "::")
    [73] AbbrevForwardStep ::= "@"? NodeTest
    ************************************************************************/
    final public AxisStep parseForwardStep() throws ParseException, XQueryException {
        int kind = AxisStep.CHILD;
        final NodeTest nodeTest;
        switch(jj_nt.kind) {
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisSelf:
            case At:
                switch(jj_nt.kind) {
                    case AxisChild:
                        currentToken = jj_consume_token(AxisChild);
                        kind = AxisStep.CHILD;
                        break;
                    case AxisDescendant:
                        currentToken = jj_consume_token(AxisDescendant);
                        kind = AxisStep.DESC;
                        break;
                    case AxisAttribute:
                    case At:
                        switch(jj_nt.kind) {
                            case AxisAttribute:
                                currentToken = jj_consume_token(AxisAttribute);
                                break;
                            case At:
                                currentToken = jj_consume_token(At);
                                break;
                            default:
                                jj_la1[127] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        kind = AxisStep.ATTR;
                        break;
                    case AxisSelf:
                        currentToken = jj_consume_token(AxisSelf);
                        kind = AxisStep.SELF;
                        break;
                    case AxisDescendantOrSelf:
                        currentToken = jj_consume_token(AxisDescendantOrSelf);
                        kind = AxisStep.DESC_OR_SELF;
                        break;
                    case AxisFollowingSibling:
                        currentToken = jj_consume_token(AxisFollowingSibling);
                        kind = AxisStep.FOLLOWING_SIBLING;
                        break;
                    case AxisFollowing:
                        currentToken = jj_consume_token(AxisFollowing);
                        kind = AxisStep.FOLLOWING;
                        break;
                    default:
                        jj_la1[128] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[129] = jj_gen;
                ;
        }
        nodeTest = parseNodeTest(kind);
        final AxisStep axis = ExpressionFactory.createAxisStep(kind, nodeTest);
        locate(axis);
        {
            if(true)
                return axis;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [74] ReverseStep ::= (ReverseAxis NodeTest) | AbbrevReverseStep
    [75] ReverseAxis ::= ("parent" "::")
    					| ("ancestor" "::")
    					| ("preceding-sibling" "::")
    					| ("preceding" "::")
    					| ("ancestor-or-self" "::")
    [76] AbbrevReverseStep :: ".."
    ************************************************************************/
    final public AxisStep parseReverseStep() throws ParseException, XQueryException {
        final int kind;
        final NodeTest nodeTest;
        switch(jj_nt.kind) {
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
                switch(jj_nt.kind) {
                    case AxisParent:
                        currentToken = jj_consume_token(AxisParent);
                        kind = AxisStep.PARENT;
                        break;
                    case AxisAncestor:
                        currentToken = jj_consume_token(AxisAncestor);
                        kind = AxisStep.ANCESTOR;
                        break;
                    case AxisPrecedingSibling:
                        currentToken = jj_consume_token(AxisPrecedingSibling);
                        kind = AxisStep.PRECEDING_SIBLING;
                        break;
                    case AxisPreceding:
                        currentToken = jj_consume_token(AxisPreceding);
                        kind = AxisStep.PRECEDING;
                        break;
                    case AxisAncestorOrSelf:
                        currentToken = jj_consume_token(AxisAncestorOrSelf);
                        kind = AxisStep.ANCESTOR_OR_SELF;
                        break;
                    default:
                        jj_la1[130] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                nodeTest = parseNodeTest(kind);
                break;
            case DotDot:
                currentToken = jj_consume_token(DotDot);
                kind = AxisStep.PARENT;
                nodeTest = NodeTest.ANYNODE;
                break;
            default:
                jj_la1[131] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        final AxisStep axis = ExpressionFactory.createAxisStep(kind, nodeTest);
        locate(axis);
        {
            if(true)
                return axis;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [77] NodeTest 	   ::= KindTest | NameTest
    [78] NameTest 	   ::= QName | Wildcard
    [79] Wildcard 	   ::= "*" | (NCName ":" "*") | ("*" ":" NCName)
    ************************************************************************/
    final public NodeTest parseNodeTest(int axis) throws ParseException, XQueryException {
        final NodeTest nt;
        NodeType kind = null;
        switch(jj_nt.kind) {
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
                kind = parseKindTest();
                nt = new NodeTest(kind);
                break;
            default:
                jj_la1[134] = jj_gen;
                if(jj_2_2(3)) {
                    switch(jj_nt.kind) {
                        case QName:
                            //NameTest	  		
                            currentToken = jj_consume_token(QName);
                            QualifiedName name = QNameUtil.parse(currentToken.image, namespaceContext, staticContext.getDefaultElementNamespace());
                            nt = new NodeTest(axis, name);
                            break;
                        case NCNameColonStar:
                        case StarColonNCName:
                        case Star:
                            switch(jj_nt.kind) {
                                case Star:
                                    //Wildcard
                                    currentToken = jj_consume_token(Star);
                                    nt = new NodeTest(axis);
                                    break;
                                case NCNameColonStar:
                                    //NCName ":" "*"
                                    currentToken = jj_consume_token(NCNameColonStar);
                                    String prefix = currentToken.image.substring(0, currentToken.image.indexOf(':'));
                                    String uri = namespaceContext.getNamespaceURI(prefix);
                                    if(uri == null) {
                                        error("err:XPST0081");
                                    }
                                    name = QNameTable.instantiate(uri, NodeTest.ANY, prefix);
                                    nt = new NodeTest(axis, name);
                                    break;
                                case StarColonNCName:
                                    //"*" ":" NCName
                                    currentToken = jj_consume_token(StarColonNCName);
                                    String ncname = currentToken.image.substring(currentToken.image.indexOf(':') + 1);
                                    name = QNameTable.instantiate(XMLConstants.NULL_NS_URI, ncname, NodeTest.ANY);
                                    nt = new NodeTest(axis, name);
                                    break;
                                default:
                                    jj_la1[132] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        default:
                            jj_la1[133] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                } else {
                    jj_consume_token(-1);
                    throw new ParseException();
                }
        }
        locate(nt);
        {
            if(true)
                return nt;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [83] PrimaryExpr     ::= Literal | VarRef | ParenthesizedExpr | ContextItemExpr 
    					   | FunctionCall | Constructor | UnorderedExpr | OrderedExpr
    [86] VarRef 	   	 ::= "$" VarName
    [87] ParenthesizedExpr ::= "(" Expr? ")"
    [88] ContextItemExpr   ::= "."
    [89] OrderedExpr 	 ::= "ordered" "{" Expr "}"
    [90] UnorderedExpr   ::= "unordered" "{" Expr "}"
    ************************************************************************/
    final public XQExpression parsePrimaryExpr() throws ParseException, XQueryException {
        boolean isUnordered = false;
        XQExpression expr = null;
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DoubleLiteral:
            case IntegerLiteral:
            case StringLiteral:
                //Literal
                expr = parseLiteral();
                break;
            case VariableIndicator:
                //VarRef
                currentToken = jj_consume_token(VariableIndicator);
                currentToken = jj_consume_token(VarName);
                String defaultNamespace = currentModule.getNamespace();
                if(defaultNamespace == null) {
                    defaultNamespace = "";
                }
                QualifiedName vn = QNameUtil.parse(currentToken.image, namespaceContext, defaultNamespace);
                Variable var = currentModule.getVariable(vn);
                if(var == null) {
                    error("err:XPST0008");
                }
                expr = new VarRef(var);
                break;
            case Lpar:
                //ParenthesizedExpr
                currentToken = jj_consume_token(Lpar);
                switch(jj_nt.kind) {
                    case DecimalLiteral:
                    case DotDot:
                    case Dot:
                    case DoubleLiteral:
                    case IntegerLiteral:
                    case Some:
                    case Every:
                    case XmlCommentStart:
                    case ProcessingInstructionStart:
                    case StartTagOpenRoot:
                    case ValidateLbrace:
                    case ValidateSchemaMode:
                    case TypeswitchLpar:
                    case ElementLbrace:
                    case AttributeLbrace:
                    case AttributeQNameLbrace:
                    case ElementQNameLbrace:
                    case DocumentLbrace:
                    case TextLbrace:
                    case PILbrace:
                    case PINCNameLbrace:
                    case CommentLbrace:
                    case OrderedOpen:
                    case UnorderedOpen:
                    case ExecuteAt:
                    case IfLpar:
                    case AxisAncestorOrSelf:
                    case AxisAncestor:
                    case AxisAttribute:
                    case AxisChild:
                    case AxisDescendantOrSelf:
                    case AxisDescendant:
                    case AxisFollowingSibling:
                    case AxisFollowing:
                    case AxisParent:
                    case AxisPrecedingSibling:
                    case AxisPreceding:
                    case AxisSelf:
                    case At:
                    case ElementType:
                    case AttributeType:
                    case SchemaElementType:
                    case SchemaAttributeType:
                    case CommentLparRpar:
                    case TextLparRpar:
                    case NodeLparRpar:
                    case DocumentLpar:
                    case ProcessingInstructionLpar:
                    case NCNameColonStar:
                    case StarColonNCName:
                    case QNameLpar:
                    case ForVariable:
                    case LetVariable:
                    case Plus:
                    case SlashSlash:
                    case Slash:
                    case StringLiteral:
                    case Star:
                    case VariableIndicator:
                    case Minus:
                    case PragmaOpen:
                    case Lpar:
                    case ElementTypeForKindTest:
                    case AttributeTypeForKindTest:
                    case SchemaElementTypeForKindTest:
                    case SchemaAttributeTypeForKindTest:
                    case CommentLparRparForKindTest:
                    case TextLparRparForKindTest:
                    case NodeLparRparForKindTest:
                    case DocumentLparForKindTest:
                    case ProcessingInstructionLparForKindTest:
                    case ElementTypeForDocumentTest:
                    case SchemaElementTypeForDocumentTest:
                    case QName:
                    case XmlCommentStartForElementContent:
                    case ProcessingInstructionStartForElementContent:
                    case StartTagOpen:
                        expr = parseExpr();
                        break;
                    default:
                        jj_la1[135] = jj_gen;
                        ;
                }
                if(expr == null) {
                    expr = SequenceExpression.EMPTY_SEQUENCE;
                } else {
                    expr = ParenthesizedExpr.normalize(expr);
                }
                currentToken = jj_consume_token(Rpar);
                break;
            case Dot:
                //ContextItemExpr
                currentToken = jj_consume_token(Dot);
                expr = new ContextItemExpr();
                break;
            case TypeswitchLpar:
            case IfLpar:
            case QNameLpar:
                //FunctionCall
                expr = parseFunctionCall();
                break;
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                //Constructor
                expr = parseConstructor();
                break;
            case OrderedOpen:
            case UnorderedOpen:
                switch(jj_nt.kind) {
                    case UnorderedOpen:
                        currentToken = jj_consume_token(UnorderedOpen);
                        isUnordered = true;
                        break;
                    case OrderedOpen:
                        currentToken = jj_consume_token(OrderedOpen);
                        break;
                    default:
                        jj_la1[136] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                expr = parseExpr();
                if(isUnordered) {
                    expr = UnorderedExpr.normalize(new UnorderedExpr(expr));
                }
                currentToken = jj_consume_token(Rbrace);
                break;
            case ExecuteAt:
                // BDQEXPR extention ; execute at URL { }
                expr = parseBDQExpr();
                break;
            default:
                jj_la1[137] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return locate(expr);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
     BDQExpr ::= "execute at" [ VarRef "in" ] Expr "{" Expr "}"
    ************************************************************************/
    final public BDQExpr parseBDQExpr() throws ParseException, XQueryException {
        final XQExpression endpoint, expr;
        ExecHostVariable hostVar = null;
        currentToken = jj_consume_token(ExecuteAt);
        if(jj_2_3(3)) {
            currentToken = jj_consume_token(VariableIndicator);
            currentToken = jj_consume_token(VarName);
            QualifiedName varName = QNameUtil.parse(currentToken.image, namespaceContext, currentModule.getNamespace());
            hostVar = new ExecHostVariable(varName);
            currentModule.putVariable(varName, hostVar);
            currentToken = jj_consume_token(In);
        } else {
            ;
        }
        endpoint = parseExpr();
        currentToken = jj_consume_token(LbraceExprEnclosure);
        expr = parseExpr();
        currentToken = jj_consume_token(Rbrace);
        final BDQExpr remoteExpr = new BDQExpr(endpoint, hostVar, expr);
        locate(remoteExpr);
        {
            if(true)
                return remoteExpr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [84]  Literal 	     ::= NumericLiteral | StringLiteral
    [85]  NumericLiteral ::= IntegerLiteral | DecimalLiteral | DoubleLiteral
    [138] IntegerLiteral ::= Digits
    [139] DecimalLiteral ::= ("." Digits) | (Digits "." [0-9]*)
    [140] DoubleLiteral  ::= (("." Digits) | (Digits ("." [0-9]*)?)) [eE] [+-]? Digits
    ************************************************************************/
    final public LiteralExpr parseLiteral() throws ParseException, XQueryException {
        final AtomicValue value;
        switch(jj_nt.kind) {
            case IntegerLiteral:
                // IntegerLiteral
                currentToken = jj_consume_token(IntegerLiteral);
                value = new XInteger(currentToken.image);
                break;
            case DecimalLiteral:
                // DecimalLiteral
                currentToken = jj_consume_token(DecimalLiteral);
                value = new XDecimal(currentToken.image);
                break;
            case DoubleLiteral:
                currentToken = jj_consume_token(DoubleLiteral);
                value = new XDouble(currentToken.image);
                break;
            case StringLiteral:
                currentToken = jj_consume_token(StringLiteral);
                String s = unescape(unquote(currentToken.image));
                if(s.indexOf('&') != -1) {
                    s = replaceReference(s);
                }
                value = new XString(s);
                break;
            default:
                jj_la1[138] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        final LiteralExpr ve = new LiteralExpr(value);
        locate(ve);
        {
            if(true)
                return ve;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [91] FunctionCall ::= <QName "("> (ExprSingle ("," ExprSingle)*)? ")"
    ************************************************************************/
    final public XQExpression parseFunctionCall() throws ParseException, XQueryException {
        final QualifiedName funcName;
        final List<XQExpression> params = new LinkedList<XQExpression>();
        XQExpression expr = null;
        switch(jj_nt.kind) {
            case TypeswitchLpar:
            case IfLpar:
                switch(jj_nt.kind) {
                    case IfLpar:
                        expr = parseIfExpr();
                        break;
                    case TypeswitchLpar:
                        expr = parseTypeswitchExpr();
                        break;
                    default:
                        jj_la1[139] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                assert (expr != null);
                {
                    if(true)
                        return expr;
                }
                break;
            default:
                jj_la1[140] = jj_gen;
                ;
        }
        assert (expr == null);
        currentToken = jj_consume_token(QNameLpar);
        funcName = QNameUtil.parse(currentToken.image.substring(0, currentToken.image.length() - 1).trim(), namespaceContext, staticContext.getDefaultFunctionNamespace());
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case Some:
            case Every:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                expr = parseExprSingle();
                params.add(expr);
                label_25: while(true) {
                    switch(jj_nt.kind) {
                        case Comma:
                            ;
                            break;
                        default:
                            jj_la1[141] = jj_gen;
                            break label_25;
                    }
                    currentToken = jj_consume_token(Comma);
                    expr = parseExprSingle();
                    params.add(expr);
                }
                break;
            default:
                jj_la1[142] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Rpar);
        {
            if(true)
                return locate(ExpressionFactory.createFunctionCall(currentModule, funcName, params, staticContext));
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [92] Constructor 	   ::= DirectConstructor | ComputedConstructor
    [93] DirectConstructor ::= DirElemConstructor | DirCommentConstructor | DirPIConstructor
    [107] ComputedConstructor ::= CompDocConstructor
    							| CompElemConstructor
    							| CompAttrConstructor
    							| CompTextConstructor
    							| CompCommentConstructor
    							| CompPIConstructor
    ************************************************************************/
    final public NodeConstructor parseConstructor() throws ParseException, XQueryException {
        final NodeConstructor expr;
        switch(jj_nt.kind) {
            case StartTagOpenRoot:
            case StartTagOpen:
                //DirectConstructor
                expr = parseDirElemConstructor();
                break;
            case XmlCommentStart:
            case XmlCommentStartForElementContent:
                expr = parseDirCommentConstructor();
                break;
            case ProcessingInstructionStart:
            case ProcessingInstructionStartForElementContent:
                expr = parseDirPIConstructor();
                break;
            case DocumentLbrace:
                //ComputedConstructor
                expr = parseCompDocConstructor();
                break;
            case ElementLbrace:
            case ElementQNameLbrace:
                expr = parseCompElemConstructor();
                break;
            case AttributeLbrace:
            case AttributeQNameLbrace:
                expr = parseCompAttrConstructor();
                break;
            case TextLbrace:
                expr = parseCompTextConstructor();
                break;
            case CommentLbrace:
                expr = parseCompCommentConstructor();
                break;
            case PILbrace:
            case PINCNameLbrace:
                expr = parseCompPIConstructor();
                break;
            default:
                jj_la1[143] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        locate(expr);
        {
            if(true)
                return expr;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [94] DirElemConstructor ::= "<" QName DirAttributeList ("/>" | (">" DirElemContent* "</" QName S? ">"))
    ************************************************************************/
    final public ElementConstructor parseDirElemConstructor() throws ParseException,
            XQueryException {
        final String startTag;
        final List<AttributeConstructorBase> atts;
        final ElementConstructor ec;
        switch(jj_nt.kind) {
            case StartTagOpenRoot:
                currentToken = jj_consume_token(StartTagOpenRoot);
                break;
            case StartTagOpen:
                currentToken = jj_consume_token(StartTagOpen);
                break;
            default:
                jj_la1[144] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        namespaceContext.pushContext();
        currentToken = jj_consume_token(TagQName);
        startTag = currentToken.image;
        atts = parseDirAttributeList();
        final QualifiedName elem = QNameUtil.parse(startTag, namespaceContext, staticContext.getDefaultElementNamespace());
        ec = new ElementConstructor(elem, atts);
        switch(jj_nt.kind) {
            case EmptyTagClose:
                currentToken = jj_consume_token(EmptyTagClose);
                break;
            case StartTagClose:
                currentToken = jj_consume_token(StartTagClose);
                XQExpression content = null;
                label_26: while(true) {
                    switch(jj_nt.kind) {
                        case XmlCommentStart:
                        case ProcessingInstructionStart:
                        case CdataSectionStart:
                        case StartTagOpenRoot:
                        case LbraceExprEnclosure:
                        case XmlCommentStartForElementContent:
                        case ProcessingInstructionStartForElementContent:
                        case CdataSectionStartForElementContent:
                        case StartTagOpen:
                        case Lbrace:
                        case PredefinedEntityRef:
                        case CharRef:
                        case LCurlyBraceEscape:
                        case RCurlyBraceEscape:
                        case ElementContentChar:
                            ;
                            break;
                        default:
                            jj_la1[145] = jj_gen;
                            break label_26;
                    }
                    //DirElemContent*
                    content = parseDirElemContent();
                    ec.addContent(content);
                }
                currentToken = jj_consume_token(EndTagOpen);
                currentToken = jj_consume_token(TagQName);
                switch(jj_nt.kind) {
                    case S:
                        currentToken = jj_consume_token(S);
                        break;
                    default:
                        jj_la1[146] = jj_gen;
                        ;
                }
                if(!startTag.equals(currentToken.image)) { //sanity check
                    error("Invalid DirElemConstructor expression");
                }
                currentToken = jj_consume_token(EndTagClose);
                break;
            default:
                jj_la1[147] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        namespaceContext.popContext();
        locate(ec);
        {
            if(true)
                return ec;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [99] DirElemContent 	::= DirectConstructor
    						| CDataSection
    						| CommonContent
    						| ElementContentChar
    [93] DirectConstructor 	::= DirElemConstructor | DirCommentConstructor | DirPIConstructor
    [100] CommonContent 	::= PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
    [105] CDataSection 	    ::= "<![CDATA[" CDataSectionContents "]]>"
    [106] CDataSectionContents ::= (Char* - (Char* ']]>' Char*))
    ************************************************************************/
    final public XQExpression parseDirElemContent() throws ParseException, XQueryException {
        final XQExpression expr;
        switch(jj_nt.kind) {
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                switch(jj_nt.kind) {
                    case StartTagOpenRoot:
                    case StartTagOpen:
                        //	DirectConstructor
                        expr = parseDirElemConstructor();
                        break;
                    case XmlCommentStart:
                    case XmlCommentStartForElementContent:
                        expr = parseDirCommentConstructor();
                        break;
                    case ProcessingInstructionStart:
                    case ProcessingInstructionStartForElementContent:
                        expr = parseDirPIConstructor();
                        break;
                    default:
                        jj_la1[148] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            case CdataSectionStart:
            case CdataSectionStartForElementContent:
                final StringBuilder cdata = new StringBuilder();
                switch(jj_nt.kind) {
                    case CdataSectionStartForElementContent:
                        currentToken = jj_consume_token(CdataSectionStartForElementContent);
                        break;
                    case CdataSectionStart:
                        currentToken = jj_consume_token(CdataSectionStart);
                        break;
                    default:
                        jj_la1[149] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                label_27: while(true) {
                    switch(jj_nt.kind) {
                        case CDataSectionChar:
                            ;
                            break;
                        default:
                            jj_la1[150] = jj_gen;
                            break label_27;
                    }
                    currentToken = jj_consume_token(CDataSectionChar);
                    cdata.append(currentToken.image);
                }
                expr = new TextContent(cdata.toString(), true);
                currentToken = jj_consume_token(CdataSectionEnd);
                break;
            case LbraceExprEnclosure:
            case Lbrace:
            case PredefinedEntityRef:
            case CharRef:
            case LCurlyBraceEscape:
            case RCurlyBraceEscape:
                //CommonContent
                expr = parseCommonContent();
                break;
            case ElementContentChar:
                final StringBuilder tc = new StringBuilder();
                label_28: while(true) {
                    //ElementContentChar			
                    currentToken = jj_consume_token(ElementContentChar);
                    tc.append(currentToken.image);
                    switch(jj_nt.kind) {
                        case ElementContentChar:
                            ;
                            break;
                        default:
                            jj_la1[151] = jj_gen;
                            break label_28;
                    }
                }
                final String tcStr;
                if(staticContext.isConstructionModeStrip()) {
                    tcStr = XMLUtils.normalizeString(tc.toString());
                } else {
                    tcStr = tc.toString();
                }
                assert (tcStr != null);
                if(tcStr.length() == 0) {
                    expr = TextContent.TrimedText.INSTANCE;
                } else {
                    expr = new TextContent(tcStr);
                }
                break;
            default:
                jj_la1[152] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return locate(expr);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [100] CommonContent 	  ::= PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
    ************************************************************************/
    final public XQExpression parseCommonContent() throws ParseException, XQueryException {
        final XQExpression expr;
        switch(jj_nt.kind) {
            case PredefinedEntityRef:
            case CharRef:
            case LCurlyBraceEscape:
            case RCurlyBraceEscape:
                switch(jj_nt.kind) {
                    case PredefinedEntityRef:
                    case CharRef:
                        switch(jj_nt.kind) {
                            case PredefinedEntityRef:
                                currentToken = jj_consume_token(PredefinedEntityRef);
                                break;
                            case CharRef:
                                currentToken = jj_consume_token(CharRef);
                                break;
                            default:
                                jj_la1[153] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        expr = new TextContent(parseCharRef(currentToken.image));
                        break;
                    case LCurlyBraceEscape:
                    case RCurlyBraceEscape:
                        switch(jj_nt.kind) {
                            case LCurlyBraceEscape:
                                currentToken = jj_consume_token(LCurlyBraceEscape);
                                break;
                            case RCurlyBraceEscape:
                                currentToken = jj_consume_token(RCurlyBraceEscape);
                                break;
                            default:
                                jj_la1[154] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        expr = new TextContent(currentToken.image);
                        break;
                    default:
                        jj_la1[155] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            case LbraceExprEnclosure:
            case Lbrace:
                switch(jj_nt.kind) {
                    case Lbrace:
                        currentToken = jj_consume_token(Lbrace);
                        break;
                    case LbraceExprEnclosure:
                        currentToken = jj_consume_token(LbraceExprEnclosure);
                        break;
                    default:
                        jj_la1[156] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                expr = parseExpr();
                currentToken = jj_consume_token(Rbrace);
                break;
            default:
                jj_la1[157] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if(true)
                return locate(expr);
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [95] DirAttributeList 	::= (S (QName S? "=" S? DirAttributeValue)?)*
    [96] DirAttributeValue 	::= ('"' (EscapeQuot | QuotAttrValueContent)* '"')	
    						  | ("'" (EscapeApos | AposAttrValueContent)* "'")
    [149] EscapeQuot ::= '""'
    [97]  QuotAttrValueContent ::= QuotAttrContentChar | CommonContent
    [152] QuotAttrContentChar ::= Char - ["{}<&]
    [150] EscapeApos ::= "''"
    [98] AposAttrValueContent ::= AposAttrContentChar | CommonContent
    [153] AposAttrContentChar ::= Char - ['{}<&]
    [100] CommonContent 	  ::= PredefinedEntityRef | CharRef | "{{" | "}}" | EnclosedExpr
    ************************************************************************/
    final public List<AttributeConstructorBase> parseDirAttributeList() throws ParseException,
            XQueryException {
        final List<AttributeConstructorBase> atts = new ArrayList<AttributeConstructorBase>(4);
        List<Pair<String, List<XQExpression>>> lazyAtts = null;
        XQExpression valueExpr = null;
        label_29: while(true) {
            switch(jj_nt.kind) {
                case S:
                    ;
                    break;
                default:
                    jj_la1[158] = jj_gen;
                    break label_29;
            }
            //DirAttributeList
            currentToken = jj_consume_token(S);
            switch(jj_nt.kind) {
                case TagQName:
                    currentToken = jj_consume_token(TagQName);
                    String attname = currentToken.image;
                    switch(jj_nt.kind) {
                        case S:
                            currentToken = jj_consume_token(S);
                            break;
                        default:
                            jj_la1[159] = jj_gen;
                            ;
                    }
                    currentToken = jj_consume_token(ValueIndicator);
                    switch(jj_nt.kind) {
                        case S:
                            currentToken = jj_consume_token(S);
                            break;
                        default:
                            jj_la1[160] = jj_gen;
                            ;
                    }
                    StringBuilder attval = new StringBuilder();
                    List<XQExpression> valueList = new LinkedList<XQExpression>();
                    switch(jj_nt.kind) {
                        case OpenQuot:
                            currentToken = jj_consume_token(OpenQuot);
                            label_30: while(true) {
                                switch(jj_nt.kind) {
                                    case LbraceExprEnclosure:
                                    case Lbrace:
                                    case PredefinedEntityRef:
                                    case CharRef:
                                    case LCurlyBraceEscape:
                                    case RCurlyBraceEscape:
                                    case EscapeQuot:
                                    case QuotAttrContentChar:
                                        ;
                                        break;
                                    default:
                                        jj_la1[161] = jj_gen;
                                        break label_30;
                                }
                                switch(jj_nt.kind) {
                                    case EscapeQuot:
                                        currentToken = jj_consume_token(EscapeQuot);
                                        attval.append("\"");
                                        break;
                                    case LbraceExprEnclosure:
                                    case Lbrace:
                                    case PredefinedEntityRef:
                                    case CharRef:
                                    case LCurlyBraceEscape:
                                    case RCurlyBraceEscape:
                                    case QuotAttrContentChar:
                                        switch(jj_nt.kind) {
                                            case QuotAttrContentChar:
                                                //QuotAttrValueContent
                                                currentToken = jj_consume_token(QuotAttrContentChar);
                                                attval.append(currentToken.image);
                                                break;
                                            case LbraceExprEnclosure:
                                            case Lbrace:
                                            case PredefinedEntityRef:
                                            case CharRef:
                                            case LCurlyBraceEscape:
                                            case RCurlyBraceEscape:
                                                //CommonContent
                                                valueExpr = parseCommonContent();
                                                if(valueExpr instanceof TextContent) {
                                                    attval.append(((TextContent) valueExpr).getValue().toString());
                                                } else {
                                                    if(attval.length() > 0) {
                                                        valueList.add(new TextContent(attval.toString()));
                                                        attval.delete(0, attval.length());
                                                    }
                                                    valueList.add(valueExpr);
                                                }
                                                break;
                                            default:
                                                jj_la1[162] = jj_gen;
                                                jj_consume_token(-1);
                                                throw new ParseException();
                                        }
                                        break;
                                    default:
                                        jj_la1[163] = jj_gen;
                                        jj_consume_token(-1);
                                        throw new ParseException();
                                }
                            }
                            currentToken = jj_consume_token(CloseQuot);
                            break;
                        case OpenApos:
                            currentToken = jj_consume_token(OpenApos);
                            label_31: while(true) {
                                switch(jj_nt.kind) {
                                    case LbraceExprEnclosure:
                                    case Lbrace:
                                    case PredefinedEntityRef:
                                    case CharRef:
                                    case LCurlyBraceEscape:
                                    case RCurlyBraceEscape:
                                    case EscapeApos:
                                    case AposAttrContentChar:
                                        ;
                                        break;
                                    default:
                                        jj_la1[164] = jj_gen;
                                        break label_31;
                                }
                                switch(jj_nt.kind) {
                                    case EscapeApos:
                                        currentToken = jj_consume_token(EscapeApos);
                                        attval.append("'");
                                        break;
                                    case LbraceExprEnclosure:
                                    case Lbrace:
                                    case PredefinedEntityRef:
                                    case CharRef:
                                    case LCurlyBraceEscape:
                                    case RCurlyBraceEscape:
                                    case AposAttrContentChar:
                                        switch(jj_nt.kind) {
                                            case AposAttrContentChar:
                                                currentToken = jj_consume_token(AposAttrContentChar);
                                                attval.append(currentToken.image);
                                                break;
                                            case LbraceExprEnclosure:
                                            case Lbrace:
                                            case PredefinedEntityRef:
                                            case CharRef:
                                            case LCurlyBraceEscape:
                                            case RCurlyBraceEscape:
                                                //CommonContent
                                                valueExpr = parseCommonContent();
                                                if(valueExpr instanceof TextContent) {
                                                    attval.append(((TextContent) valueExpr).getValue().toString());
                                                } else {
                                                    if(attval.length() > 0) {
                                                        valueList.add(new TextContent(attval.toString()));
                                                        attval.delete(0, attval.length());
                                                    }
                                                    valueList.add(valueExpr);
                                                }
                                                break;
                                            default:
                                                jj_la1[165] = jj_gen;
                                                jj_consume_token(-1);
                                                throw new ParseException();
                                        }
                                        break;
                                    default:
                                        jj_la1[166] = jj_gen;
                                        jj_consume_token(-1);
                                        throw new ParseException();
                                }
                            }
                            currentToken = jj_consume_token(CloseApos);
                            break;
                        default:
                            jj_la1[167] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    // process an attribute.
                    String[] str = attname.split(":");
                    if(XMLConstants.XMLNS_ATTRIBUTE.equals(str[0])) { // namespace decl						
                        if(valueExpr != null) { // the value of namespace decl must be an URI.
                            error("err:XQST0022");
                        }
                        final String prefix;
                        if(str.length == 1) {
                            prefix = "";
                        } else {
                            prefix = str[1];
                        }
                        final String val = attval.toString();
                        declarePrefix(prefix, val);
                        NamespaceConstructor nc = new NamespaceConstructor(prefix, val);
                        locate(nc);
                        atts.add(nc);
                    } else { // attribute
                        if(attval.length() > 0) {
                            valueList.add(new TextContent(attval.toString()));
                        }
                        if(lazyAtts == null) {
                            lazyAtts = new LinkedList<Pair<String, List<XQExpression>>>();
                        }
                        lazyAtts.add(new Pair<String, List<XQExpression>>(attname, valueList));
                    }
                    break;
                default:
                    jj_la1[168] = jj_gen;
                    ;
            }
        }
        // for dynamic namaespace decl
        // TODO consider decled namespace is used in the attribute value.
        if(lazyAtts != null) {
            for(Pair<String, List<XQExpression>> p : lazyAtts) {
                QualifiedName att = QNameUtil.parse(p.first, namespaceContext, staticContext.getDefaultElementNamespace());
                AttributeConstructor ac = new AttributeConstructor(att, p.second);
                locate(ac);
                atts.add(ac);
            }
        }
        {
            if(true)
                return atts;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [101] DirCommentConstructor ::= "<!--" DirCommentContents "-->"
    [102] DirCommentContents    ::= ((Char - '-') | ('-' (Char - '-')))*
    ************************************************************************/
    final public CommentConstructor parseDirCommentConstructor() throws ParseException,
            XQueryException {
        final StringBuilder content = new StringBuilder();
        switch(jj_nt.kind) {
            case XmlCommentStartForElementContent:
                currentToken = jj_consume_token(XmlCommentStartForElementContent);
                break;
            case XmlCommentStart:
                currentToken = jj_consume_token(XmlCommentStart);
                break;
            default:
                jj_la1[169] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        label_32: while(true) {
            switch(jj_nt.kind) {
                case CommentContentChar:
                    ;
                    break;
                default:
                    jj_la1[170] = jj_gen;
                    break label_32;
            }
            currentToken = jj_consume_token(CommentContentChar);
            content.append(currentToken.image);
        }
        currentToken = jj_consume_token(XmlCommentEnd);
        final CommentConstructor cc = new CommentConstructor(content.toString());
        locate(cc);
        {
            if(true)
                return cc;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [103] DirPIConstructor ::= "<?" PITarget (S DirPIContents)? "?>"
    [104] DirPIContents    ::= (Char* - (Char* '?>' Char*))
    [17]  PITarget	   	   ::= Name - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
    [5]   Name	   		   ::= (Letter | '_' | ':') (NameChar)*
    ************************************************************************/
    final public PIConstructor parseDirPIConstructor() throws ParseException, XQueryException {
        final String target;
        StringBuilder contentBuf = new StringBuilder(64);
        switch(jj_nt.kind) {
            case ProcessingInstructionStartForElementContent:
                currentToken = jj_consume_token(ProcessingInstructionStartForElementContent);
                break;
            case ProcessingInstructionStart:
                currentToken = jj_consume_token(ProcessingInstructionStart);
                break;
            default:
                jj_la1[171] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        currentToken = jj_consume_token(PITarget);
        target = currentToken.image;
        switch(jj_nt.kind) {
            case SForPI:
                currentToken = jj_consume_token(SForPI);
                label_33: while(true) {
                    switch(jj_nt.kind) {
                        case PIContentChar:
                            ;
                            break;
                        default:
                            jj_la1[172] = jj_gen;
                            break label_33;
                    }
                    currentToken = jj_consume_token(PIContentChar);
                    contentBuf.append(currentToken.image);
                }
                break;
            default:
                jj_la1[173] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(ProcessingInstructionEnd);
        final String content = contentBuf.toString();
        final PIConstructor pi = new PIConstructor(target, content.length() == 0 ? null : content);
        locate(pi);
        {
            if(true)
                return pi;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [108]    	CompDocConstructor 	   ::=    	<"document" "{"> Expr "}"
    ************************************************************************/
    final public DocConstructor parseCompDocConstructor() throws ParseException, XQueryException {
        final XQExpression expr;
        currentToken = jj_consume_token(DocumentLbrace);
        expr = parseExpr();
        currentToken = jj_consume_token(Rbrace);
        final DocConstructor dc = new DocConstructor(expr);
        locate(dc);
        {
            if(true)
                return dc;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [109] CompElemConstructor ::= (("element" QName "{") | ("element" "{" Expr "}" "{")) ContentExpr? "}"
    ************************************************************************/
    final public ElementConstructor parseCompElemConstructor() throws ParseException,
            XQueryException {
        final ElementConstructor ec;
        XQExpression nameExpr = null;
        XQExpression content = null;
        switch(jj_nt.kind) {
            case ElementQNameLbrace:
                currentToken = jj_consume_token(ElementQNameLbrace);
                QualifiedName name = QNameUtil.parse(currentToken.image.substring(8, currentToken.image.length() - 1).trim(), namespaceContext, staticContext.getDefaultElementNamespace());
                ec = new ElementConstructor(name);
                break;
            case ElementLbrace:
                currentToken = jj_consume_token(ElementLbrace);
                nameExpr = parseExpr();
                ec = new ElementConstructor(nameExpr);
                currentToken = jj_consume_token(Rbrace);
                currentToken = jj_consume_token(LbraceExprEnclosure);
                break;
            default:
                jj_la1[174] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case Some:
            case Every:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                //ContentExpr?
                content = parseExpr();
                ec.addContent(content);
                break;
            default:
                jj_la1[175] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Rbrace);
        locate(ec);
        {
            if(true)
                return ec;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [111] CompAttrConstructor ::= (("attribute" QName "{") | ("attribute" "{" Expr "}" "{")) Expr? "}"
    ************************************************************************/
    final public AttributeConstructor parseCompAttrConstructor() throws ParseException,
            XQueryException {
        final AttributeConstructor ac;
        XQExpression nameExpr = null;
        XQExpression valueExpr = null;
        switch(jj_nt.kind) {
            case AttributeQNameLbrace:
                currentToken = jj_consume_token(AttributeQNameLbrace);
                QualifiedName name = QNameUtil.parse(currentToken.image.substring(10, currentToken.image.length() - 1).trim(), namespaceContext, staticContext.getDefaultElementNamespace());
                ac = new AttributeConstructor(name);
                break;
            case AttributeLbrace:
                currentToken = jj_consume_token(AttributeLbrace);
                nameExpr = parseExpr();
                ac = new AttributeConstructor(nameExpr);
                currentToken = jj_consume_token(Rbrace);
                currentToken = jj_consume_token(LbraceExprEnclosure);
                break;
            default:
                jj_la1[176] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case Some:
            case Every:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                valueExpr = parseExpr();
                ac.addValue(valueExpr);
                break;
            default:
                jj_la1[177] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Rbrace);
        locate(ac);
        {
            if(true)
                return ac;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [112] CompTextConstructor ::= <"text" "{"> Expr "}"
    ************************************************************************/
    final public TextConstructor parseCompTextConstructor() throws ParseException, XQueryException {
        final XQExpression content;
        currentToken = jj_consume_token(TextLbrace);
        content = parseExpr();
        currentToken = jj_consume_token(Rbrace);
        final TextConstructor tc = new TextConstructor(content);
        locate(tc);
        {
            if(true)
                return tc;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [113] CompCommentConstructor ::= <"comment" "{"> Expr "}"
    ************************************************************************/
    final public CommentConstructor parseCompCommentConstructor() throws ParseException,
            XQueryException {
        final XQExpression content;
        currentToken = jj_consume_token(CommentLbrace);
        content = parseExpr();
        currentToken = jj_consume_token(Rbrace);
        final CommentConstructor cc = new CommentConstructor(content);
        locate(cc);
        {
            if(true)
                return cc;
        }
        throw new Error("Missing return statement in function");
    }

    /************************************************************************
    [114] CompPIConstructor ::= (("processing-instruction" NCName "{") | 
    							 ("processing-instruction" "{" Expr "}" "{")
    							) Expr? "}"
    ************************************************************************/
    final public PIConstructor parseCompPIConstructor() throws ParseException, XQueryException {
        String target = null;
        XQExpression targetExpr = null;
        XQExpression contentExpr = null;
        switch(jj_nt.kind) {
            case PINCNameLbrace:
                currentToken = jj_consume_token(PINCNameLbrace);
                target = currentToken.image.substring(23, currentToken.image.length() - 1).trim();
                break;
            case PILbrace:
                currentToken = jj_consume_token(PILbrace);
                targetExpr = parseExpr();
                currentToken = jj_consume_token(Rbrace);
                currentToken = jj_consume_token(LbraceExprEnclosure);
                break;
            default:
                jj_la1[178] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        switch(jj_nt.kind) {
            case DecimalLiteral:
            case DotDot:
            case Dot:
            case DoubleLiteral:
            case IntegerLiteral:
            case Some:
            case Every:
            case XmlCommentStart:
            case ProcessingInstructionStart:
            case StartTagOpenRoot:
            case ValidateLbrace:
            case ValidateSchemaMode:
            case TypeswitchLpar:
            case ElementLbrace:
            case AttributeLbrace:
            case AttributeQNameLbrace:
            case ElementQNameLbrace:
            case DocumentLbrace:
            case TextLbrace:
            case PILbrace:
            case PINCNameLbrace:
            case CommentLbrace:
            case OrderedOpen:
            case UnorderedOpen:
            case ExecuteAt:
            case IfLpar:
            case AxisAncestorOrSelf:
            case AxisAncestor:
            case AxisAttribute:
            case AxisChild:
            case AxisDescendantOrSelf:
            case AxisDescendant:
            case AxisFollowingSibling:
            case AxisFollowing:
            case AxisParent:
            case AxisPrecedingSibling:
            case AxisPreceding:
            case AxisSelf:
            case At:
            case ElementType:
            case AttributeType:
            case SchemaElementType:
            case SchemaAttributeType:
            case CommentLparRpar:
            case TextLparRpar:
            case NodeLparRpar:
            case DocumentLpar:
            case ProcessingInstructionLpar:
            case NCNameColonStar:
            case StarColonNCName:
            case QNameLpar:
            case ForVariable:
            case LetVariable:
            case Plus:
            case SlashSlash:
            case Slash:
            case StringLiteral:
            case Star:
            case VariableIndicator:
            case Minus:
            case PragmaOpen:
            case Lpar:
            case ElementTypeForKindTest:
            case AttributeTypeForKindTest:
            case SchemaElementTypeForKindTest:
            case SchemaAttributeTypeForKindTest:
            case CommentLparRparForKindTest:
            case TextLparRparForKindTest:
            case NodeLparRparForKindTest:
            case DocumentLparForKindTest:
            case ProcessingInstructionLparForKindTest:
            case ElementTypeForDocumentTest:
            case SchemaElementTypeForDocumentTest:
            case QName:
            case XmlCommentStartForElementContent:
            case ProcessingInstructionStartForElementContent:
            case StartTagOpen:
                contentExpr = parseExpr();
                break;
            default:
                jj_la1[179] = jj_gen;
                ;
        }
        currentToken = jj_consume_token(Rbrace);
        final PIConstructor pi;
        if(target != null) {
            pi = new PIConstructor(target, contentExpr);
        } else {
            pi = new PIConstructor(targetExpr, contentExpr);
        }
        locate(pi);
        {
            if(true)
                return pi;
        }
        throw new Error("Missing return statement in function");
    }

    private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    private boolean jj_2_2(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_2();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(1, xla);
        }
    }

    private boolean jj_2_3(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_3();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(2, xla);
        }
    }

    private boolean jj_3_2() {
        Token xsp;
        xsp = jj_scanpos;
        if(jj_3R_35()) {
            jj_scanpos = xsp;
            if(jj_3R_36())
                return true;
        }
        return false;
    }

    private boolean jj_3R_38() {
        if(jj_scan_token(NCNameColonStar))
            return true;
        return false;
    }

    private boolean jj_3R_37() {
        if(jj_scan_token(Star))
            return true;
        return false;
    }

    private boolean jj_3R_36() {
        Token xsp;
        xsp = jj_scanpos;
        if(jj_3R_37()) {
            jj_scanpos = xsp;
            if(jj_3R_38()) {
                jj_scanpos = xsp;
                if(jj_3R_39())
                    return true;
            }
        }
        return false;
    }

    private boolean jj_3_1() {
        if(jj_scan_token(PragmaOpen))
            return true;
        Token xsp;
        xsp = jj_scanpos;
        if(jj_scan_token(190))
            jj_scanpos = xsp;
        if(jj_scan_token(QNameForPragma))
            return true;
        xsp = jj_scanpos;
        if(jj_3R_34())
            jj_scanpos = xsp;
        if(jj_scan_token(PragmaClose))
            return true;
        return false;
    }

    private boolean jj_3R_39() {
        if(jj_scan_token(StarColonNCName))
            return true;
        return false;
    }

    private boolean jj_3R_35() {
        if(jj_scan_token(QName))
            return true;
        return false;
    }

    private boolean jj_3_3() {
        if(jj_scan_token(VariableIndicator))
            return true;
        if(jj_scan_token(VarName))
            return true;
        if(jj_scan_token(In))
            return true;
        return false;
    }

    private boolean jj_3R_34() {
        if(jj_scan_token(PragmaContents))
            return true;
        return false;
    }

    /** Generated Token Manager. */
    public XQueryParserTokenManager token_source;
    JavaCharStream jj_input_stream;
    /** Current token. */
    public Token token;
    /** Next token. */
    public Token jj_nt;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    final private int[] jj_la1 = new int[180];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private int[] jj_la1_3;
    static private int[] jj_la1_4;
    static private int[] jj_la1_5;
    static private int[] jj_la1_6;
    static private int[] jj_la1_7;
    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
        jj_la1_init_3();
        jj_la1_init_4();
        jj_la1_init_5();
        jj_la1_init_6();
        jj_la1_init_7();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[] { 0x0, 0x0, 0xfeffff7c, 0x407ef00, 0x4042700, 0x30000, 0x407ef00,
                0x200000, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0xc000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0xfad8007c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x180000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0xfac0007c, 0x18000000, 0xe2c0007c, 0xe2c0007c, 0x0, 0x0, 0x0, 0x0,
                0xfad8007c, 0xe2c0007c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0, 0x0, 0x0, 0xfad8007c,
                0x0, 0xe2c00074, 0x64, 0x20000000, 0x20000000, 0x0, 0xfad8007c, 0xc2c00000,
                0x2000000, 0x3c00000, 0x0, 0x0, 0x2c00000, 0x1000000, 0x0, 0x0, 0x3c00000, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x400000, 0x0, 0x800000, 0x0, 0x0, 0x40000000, 0xfad8007c, 0x80000000, 0xfad8007c,
                0x0, 0xfad8007c, };
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[] { 0x0, 0x1000, 0xffffefff, 0x800, 0x800, 0x0, 0x800, 0x2080, 0x2080,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0000000, 0x0, 0x0, 0xf0000000, 0x0, 0x0, 0x0, 0x0,
                0xf0000000, 0x0, 0x50000000, 0x50000000, 0x0, 0x0, 0x0, 0x10000000, 0x0, 0x0, 0x0,
                0x0, 0x40000000, 0x20000000, 0x0, 0x0, 0x0, 0x80000000, 0x0, 0xffffc77f, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xffffc77f, 0x0, 0xffffc77f, 0xffffc77f, 0x0,
                0x0, 0x0, 0x0, 0xffffc77f, 0xffffc77f, 0x0, 0x8020000, 0xc7e0000, 0xc7e0000,
                0x3818000, 0x3818000, 0x0, 0x0, 0xf0000000, 0xffffc77f, 0x300, 0x477f, 0x0, 0x4000,
                0x4000, 0x0, 0xffffc77f, 0x7f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x2, 0xffffc77f, 0x1, 0xffffc77f, 0x30, 0xffffc77f, };
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[] { 0x0, 0x0, 0xd3f6ff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc000000,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x1000000, 0x0, 0x0, 0x40000000,
                0x20000, 0x40100, 0x40200000, 0x0, 0x80000, 0x0, 0x0, 0x1f, 0x10000, 0x10000, 0x1f,
                0x1, 0x2, 0x4, 0x7, 0x1f, 0x8, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000, 0xd3f6ff, 0x600, 0x600, 0x0, 0x400, 0x0,
                0x0, 0x0, 0x80000, 0x0, 0x0, 0x0, 0x80000, 0x0, 0x0, 0x0, 0x80000, 0x0, 0x80000,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000, 0x0, 0x0, 0x20000, 0x20000, 0x0,
                0x80000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x101000, 0x101000, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x101000, 0x101000, 0xc3e0ff,
                0x0, 0x8380ff, 0x83e0ff, 0x6000, 0x6000, 0x0, 0x0, 0xd3f6ff, 0x8380ff, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x10060, 0x10060, 0x1f, 0xd3f6ff, 0x0, 0x828080, 0x8000, 0x0,
                0x0, 0x80000, 0xd3f6ff, 0x0, 0x0, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x200000,
                0x0, 0x0, 0x0, 0x200000, 0x200000, 0x0, 0x0, 0x0, 0x200000, 0x200000, 0x200000,
                0x200000, 0x200000, 0x200000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd3f6ff,
                0x0, 0xd3f6ff, 0x0, 0xd3f6ff, };
    }

    private static void jj_la1_init_3() {
        jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x1000000, 0x6000000, 0x0, 0x6000000, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x8000000, 0x0, 0x7e0, 0xa82808, 0x121000, 0xba3fe8, 0xba3fe8, 0x40000000, 0x0,
                0x0, 0x404004, 0x404004, 0x80000000, 0x80000000, 0x8010, 0x8010, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x40000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_init_4() {
        jj_la1_4 = new int[] { 0x100000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc00,
                0xc0000000, 0xc000000, 0x30000000, 0x30000000, 0x400000, 0x0, 0x10000000, 0x400000,
                0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x0, 0x40000, 0x40000,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2, 0x0, 0x0,
                0x0, 0x0, 0x80, 0x0, 0x0, 0x80, 0x0, 0x80, 0x0, 0x80, 0x0, 0x10000, 0x3000, 0x3000,
                0xc00, 0xc00, 0x10000, 0x0, 0x80, 0x0, 0x80, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x100, 0x100, 0x1, 0x1, 0x0, 0x0, 0x10, 0x20, 0x0,
                0x40000, 0x4, 0x0, 0x40000, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    private static void jj_la1_init_5() {
        jj_la1_5 = new int[] { 0x0, 0x0, 0x20181ff0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0xa000, 0x18fff0, 0x2000000, 0x2000000, 0x18fff8, 0x100, 0x200, 0x400,
                0x700, 0x181ff0, 0x800, 0x180050, 0x180050, 0x1000, 0x600000, 0x600000, 0x80010,
                0x60000, 0x1000000, 0x800000, 0x60000, 0x100040, 0x20, 0x60000, 0x800000, 0x60000,
                0x80, 0x0, 0x20181ff0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0xa000, 0x0, 0x0, 0xa000, 0x0, 0x0, 0x0, 0x0, 0x20181ff0,
                0x0, 0x20181ff0, 0x20181ff0, 0x0, 0x0, 0x40000000, 0x80000000, 0x20181ff0,
                0x20181ff0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x181ff0, 0x20181ff0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20181ff0, 0x0, 0x0, 0x0, 0x40000000, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40000000, 0x40000000, 0x40000000, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20181ff0, 0x0,
                0x20181ff0, 0x0, 0x20181ff0, };
    }

    private static void jj_la1_init_6() {
        jj_la1_6 = new int[] { 0x0, 0x0, 0x1600, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1600, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1600, 0x0, 0x1600, 0x1600, 0x0, 0x0, 0x0, 0x0,
                0x1600, 0x1600, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1600, 0x0, 0x1600,
                0x0, 0x0, 0x0, 0x0, 0x1600, 0x1600, 0x1000, 0x7fe00, 0x0, 0xc, 0x1600, 0x800,
                0x10000000, 0x40000, 0x7fe00, 0xc000, 0x30000, 0x3c000, 0x2000, 0x3e000, 0x0, 0x0,
                0x0, 0xc003e000, 0x8003e000, 0xc003e000, 0x3e000, 0x3e000, 0x3e000, 0x30, 0x80,
                0x200, 0x200000, 0x400, 0x4000000, 0x800000, 0x0, 0x1600, 0x0, 0x1600, 0x0, 0x1600, };
    }

    private static void jj_la1_init_7() {
        jj_la1_7 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x4, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[3];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    /** Constructor with InputStream. */
    public XQueryParser(java.io.InputStream stream) {
        this(stream, null);
    }

    /** Constructor with InputStream and supplied encoding */
    public XQueryParser(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new XQueryParserTokenManager(jj_input_stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    /** Reinitialise. */
    public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Constructor. */
    public XQueryParser(java.io.Reader stream) {
        jj_input_stream = new JavaCharStream(stream, 1, 1);
        token_source = new XQueryParserTokenManager(jj_input_stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Constructor with generated Token Manager. */
    public XQueryParser(XQueryParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /** Reinitialise. */
    public void ReInit(XQueryParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        token.next = jj_nt = token_source.getNextToken();
        jj_gen = 0;
        for(int i = 0; i < 180; i++)
            jj_la1[i] = -1;
        for(int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken = token;
        if((token = jj_nt).next != null)
            jj_nt = jj_nt.next;
        else
            jj_nt = jj_nt.next = token_source.getNextToken();
        if(token.kind == kind) {
            jj_gen++;
            if(++jj_gc > 100) {
                jj_gc = 0;
                for(int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while(c != null) {
                        if(c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        jj_nt = token;
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind) {
        if(jj_scanpos == jj_lastpos) {
            jj_la--;
            if(jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if(jj_rescan) {
            int i = 0;
            Token tok = token;
            while(tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if(tok != null)
                jj_add_error_token(kind, i);
        }
        if(jj_scanpos.kind != kind)
            return true;
        if(jj_la == 0 && jj_scanpos == jj_lastpos)
            throw jj_ls;
        return false;
    }

    /** Get the next Token. */
    final public Token getNextToken() {
        if((token = jj_nt).next != null)
            jj_nt = jj_nt.next;
        else
            jj_nt = jj_nt.next = token_source.getNextToken();
        jj_gen++;
        return token;
    }

    /** Get the specific Token. */
    final public Token getToken(int index) {
        Token t = token;
        for(int i = 0; i < index; i++) {
            if(t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if(pos >= 100)
            return;
        if(pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if(jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for(int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop: for(java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
                int[] oldentry = (int[]) (it.next());
                if(oldentry.length == jj_expentry.length) {
                    for(int i = 0; i < jj_expentry.length; i++) {
                        if(oldentry[i] != jj_expentry[i]) {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if(pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /** Generate ParseException. */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[251];
        if(jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for(int i = 0; i < 180; i++) {
            if(jj_la1[i] == jj_gen) {
                for(int j = 0; j < 32; j++) {
                    if((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                    if((jj_la1_3[i] & (1 << j)) != 0) {
                        la1tokens[96 + j] = true;
                    }
                    if((jj_la1_4[i] & (1 << j)) != 0) {
                        la1tokens[128 + j] = true;
                    }
                    if((jj_la1_5[i] & (1 << j)) != 0) {
                        la1tokens[160 + j] = true;
                    }
                    if((jj_la1_6[i] & (1 << j)) != 0) {
                        la1tokens[192 + j] = true;
                    }
                    if((jj_la1_7[i] & (1 << j)) != 0) {
                        la1tokens[224 + j] = true;
                    }
                }
            }
        }
        for(int i = 0; i < 251; i++) {
            if(la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for(int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /** Enable tracing. */
    final public void enable_tracing() {}

    /** Disable tracing. */
    final public void disable_tracing() {}

    private void jj_rescan_token() {
        jj_rescan = true;
        for(int i = 0; i < 3; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if(p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch(i) {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                        }
                    }
                    p = p.next;
                } while(p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while(p.gen > jj_gen) {
            if(p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
